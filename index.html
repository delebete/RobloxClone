<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roblox-Style Multiplayer</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #232527; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* Debugger */
        #debug-console {
            position: absolute; top: 10px; left: 10px; width: 300px; height: 150px;
            background: rgba(0, 0, 0, 0.7); color: #0f0; font-family: monospace; font-size: 11px;
            padding: 10px; border-radius: 4px; pointer-events: none; overflow-y: auto; z-index: 300;
            white-space: pre-wrap;
        }

        /* Login Modal */
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #232527; z-index: 200; display: flex; justify-content: center; align-items: center; flex-direction: column;
        }
        .login-box {
            background: #393b3d; padding: 40px; border-radius: 10px; text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); width: 300px;
        }
        .login-box h1 { color: white; margin-top: 0; }
        .login-box input {
            width: 100%; padding: 10px; margin: 15px 0; border-radius: 5px; border: 1px solid #555;
            background: #232527; color: white; font-size: 16px; box-sizing: border-box;
        }
        .login-btn {
            width: 100%; padding: 12px; background: #00a2ff; color: white; border: none;
            border-radius: 5px; font-size: 16px; font-weight: bold; cursor: pointer;
        }
        .login-btn:hover { background: #008ecc; }
        
        #network-status { position: absolute; bottom: 10px; left: 10px; color: #888; font-size: 12px; pointer-events: none; z-index: 201; }

        /* Game UI */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 8px;
            pointer-events: none; user-select: none; max-width: 300px; transition: opacity 0.3s;
        }
        
        /* Tools UI */
        #editor-ui {
            position: absolute; top: 20px; right: 20px; width: 240px;
            background: rgba(35, 37, 39, 0.95); color: white; padding: 15px;
            border-radius: 8px; border: 1px solid #444; display: none;
            max-height: calc(100vh - 100px); overflow-y: auto; z-index: 90;
        }
        
        #toggle-editor-btn {
            position: absolute; bottom: 20px; right: 20px; padding: 10px 20px;
            background: #00a2ff; color: white; border: none; border-radius: 4px;
            font-weight: bold; cursor: pointer; font-size: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); pointer-events: auto; z-index: 100; 
        }
        #toggle-editor-btn:hover { background: #008ecc; }

        /* Editor Styling */
        .editor-section { margin-bottom: 15px; border-bottom: 1px solid #555; padding-bottom: 10px; }
        .editor-section h3 { margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; color: #ccc; }
        .editor-row { display: flex; gap: 5px; margin-bottom: 5px; }
        .tab-row { display: flex; margin-bottom: 15px; border-bottom: 2px solid #444; }
        .tab-btn { flex: 1; background: transparent; border: none; color: #aaa; padding: 8px; cursor: pointer; font-weight: bold; border-bottom: 2px solid transparent; margin-bottom: -2px; }
        .tab-btn.active { color: #00a2ff; border-bottom-color: #00a2ff; }
        button.tool-btn { flex: 1; padding: 5px; background: #444; border: 1px solid #555; color: white; cursor: pointer; border-radius: 3px; }
        button.tool-btn:hover { background: #555; }
        button.tool-btn.active { background: #00a2ff; border-color: #00a2ff; }
        button.undo-btn { width: 100%; padding: 8px; background: #f39c12; color: white; border: none; border-radius: 3px; cursor: pointer; margin-bottom: 10px; font-weight: bold; }
        .checkbox-row { display: flex; align-items: center; gap: 10px; margin: 5px 0; background: #333; padding: 5px; border-radius: 4px; }
        input[type="checkbox"] { width: auto; margin: 0; cursor: pointer; }
        select, input[type="color"] { width: 100%; padding: 5px; background: #333; border: 1px solid #555; color: white; border-radius: 3px; margin-bottom: 5px; pointer-events: auto; }
        label { font-size: 12px; color: #aaa; display: block; margin-bottom: 2px; }

        /* Crosshair */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 10; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.8); border-radius: 2px; }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        .key { background: #ddd; color: #333; padding: 2px 6px; border-radius: 4px; font-weight: bold; display: inline-block; min-width: 15px; text-align: center; }
        .status-badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 12px; background: #444; margin-top: 5px; }
        .on { background: #2ecc71; color: white; }
        .off { background: #e74c3c; color: white; }
        .hidden { display: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "firebase/app": "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js",
                "firebase/auth": "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js",
                "firebase/firestore": "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"
            }
        }
    </script>
</head>
<body>

    <!-- Login Screen -->
    <div id="login-screen">
        <div class="login-box">
            <h1>Blox World</h1>
            <input type="text" id="username-input" placeholder="Enter Username" maxlength="12">
            <button class="login-btn" id="join-btn">Join Game</button>
            <p id="connection-msg" style="color:#888; font-size:12px; margin-top:10px;"></p>
        </div>
    </div>

    <div id="network-status">Initializing...</div>
    <div id="debug-console">System Ready...</div>

    <div id="crosshair"></div>

    <div id="ui-layer">
        <h1>Baseplate Demo</h1>
        <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> to Walk</p>
        <p><span class="key">Space</span> to Jump</p>
        <p><span class="key">Shift</span> Toggle Shift Lock</p>
        <p><span class="key">Right Click (Hold)</span> Rotate Camera</p>
        <p><span class="key">Scroll</span> Zoom</p>
        <div style="margin-top: 10px; border-top: 1px solid #666; padding-top: 10px;">
            <div>Shift Lock: <span id="shift-status" class="status-badge off">OFF</span></div>
        </div>
    </div>

    <button id="toggle-editor-btn" style="display:none;">Open Tools</button>

    <div id="editor-ui">
        <div class="tab-row">
            <button class="tab-btn active" id="tab-avatar" onclick="window.gameEditor.setTab('avatar')">Avatar</button>
            <button class="tab-btn" id="tab-world" onclick="window.gameEditor.setTab('world')">Building</button>
        </div>
        <button class="undo-btn" onclick="window.gameEditor.undo()">â†© Undo Action</button>
        
        <div id="content-avatar">
            <div class="editor-section">
                <h3>Wearables</h3>
                <div class="editor-row">
                    <button class="tool-btn" onclick="window.gameEditor.addPart('box')">Cube</button>
                    <button class="tool-btn" onclick="window.gameEditor.addPart('cylinder')">Cylinder</button>
                </div>
                <label>Attach To:</label>
                <select id="parent-selector">
                    <option value="torso">Torso</option>
                    <option value="head">Head</option>
                    <option value="leftArm">Left Arm</option>
                    <option value="rightArm">Right Arm</option>
                    <option value="leftLeg">Left Leg</option>
                    <option value="rightLeg">Right Leg</option>
                </select>
            </div>
        </div>

        <div id="content-world" class="hidden">
            <div class="editor-section">
                <h3>Create Part</h3>
                <div class="editor-row">
                    <button class="tool-btn" onclick="window.gameEditor.addWorldPart('box')">Part</button>
                    <button class="tool-btn" onclick="window.gameEditor.addWorldPart('cylinder')">Cylinder</button>
                </div>
                <div class="editor-row">
                     <button class="tool-btn" onclick="window.gameEditor.addWorldPart('wedge')">Wedge</button>
                </div>
            </div>
            <div class="editor-section">
                <h3>Baseplate</h3>
                <label>Baseplate Color</label>
                <input type="color" id="baseplate-color-picker" value="#999999">
            </div>
        </div>

        <div class="editor-section">
            <h3>Tools</h3>
            <div class="editor-row">
                <button class="tool-btn active" id="mode-translate" onclick="window.gameEditor.setMode('translate')">Move (1)</button>
                <button class="tool-btn" id="mode-rotate" onclick="window.gameEditor.setMode('rotate')">Rotate (2)</button>
                <button class="tool-btn" id="mode-scale" onclick="window.gameEditor.setMode('scale')">Scale (3)</button>
            </div>
            <label style="margin-top:5px;">Properties</label>
            <div class="checkbox-row">
                <input type="checkbox" id="check-anchor" checked onchange="window.gameEditor.setAnchored(this.checked)">
                <label for="check-anchor" style="color:white; cursor:pointer; margin:0;">Anchored</label>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="check-collide" checked onchange="window.gameEditor.setCanCollide(this.checked)">
                <label for="check-collide" style="color:white; cursor:pointer; margin:0;">Can Collide</label>
            </div>
            <label>Color</label>
            <input type="color" id="color-picker" value="#ff0000">
            <button class="tool-btn" style="background: #e74c3c; margin-top:5px; width:100%;" onclick="window.gameEditor.deleteSelected()">Delete Selected</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';
        import { initializeApp } from 'firebase/app';
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'firebase/auth';
        import { getFirestore, collection, doc, setDoc, addDoc, onSnapshot, deleteDoc, updateDoc, serverTimestamp } from 'firebase/firestore';

        // --- Debug Logger ---
        function log(msg) {
            const consoleEl = document.getElementById('debug-console');
            consoleEl.innerText += `\n> ${msg}`;
            consoleEl.scrollTop = consoleEl.scrollHeight;
            console.log(msg);
        }

        // --- FIREBASE CONFIGURATION (USER PROVIDED) ---
        const firebaseConfig = {
          apiKey: "AIzaSyCzUQXDXgsNt1QZqqeoNDQ4PBfQNjnS_Ag",
          authDomain: "robloxclone-d2bd3.firebaseapp.com",
          projectId: "robloxclone-d2bd3",
          storageBucket: "robloxclone-d2bd3.firebasestorage.app",
          messagingSenderId: "346879775122",
          appId: "1:346879775122:web:4c0cd9ecfc0d540b41314b"
        };

        // --- INIT FIREBASE ---
        let app, auth, db;
        let isOffline = false;

        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            document.getElementById('network-status').textContent = "Connecting to Server...";
            log("Firebase Initialized. Waiting for Auth...");
        } catch (e) {
            console.error("Firebase Init Error:", e);
            isOffline = true;
            document.getElementById('network-status').textContent = "Offline Mode";
            log("ERROR: Firebase failed to init. " + e.message);
        }

        // --- Global Game State ---
        let localPlayerId = null;
        let localPlayerName = "Guest";
        let isGameActive = false;
        const remotePlayers = {}; 
        const worldObjects = {}; 

        // --- Configuration ---
        const COLORS = {
            head: 0xF5CD2F, torso: 0x0D69AC, arms: 0xF5CD2F, legs: 0xA4BD47,
            baseplate: 0x999999, studs: 0x777777
        };
        const WALK_SPEED = 16;
        const JUMP_FORCE = 25;
        const GRAVITY = -60;
        const ROTATION_SPEED = 10;

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 250);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting & Env
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.001; 
        scene.add(dirLight);
        
        const groundSize = 400;
        const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMat = new THREE.MeshStandardMaterial({ color: COLORS.baseplate, roughness: 0.8 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        ground.userData = { name: "Baseplate", isWorld: true, anchored: true, canCollide: true };
        scene.add(ground); 
        scene.add(new THREE.GridHelper(groundSize, 100, 0x555555, 0x888888));

        // Groups
        const worldGroup = new THREE.Group();
        scene.add(worldGroup);
        const playerGroup = new THREE.Group();
        scene.add(playerGroup); 
        const remotePlayersGroup = new THREE.Group();
        scene.add(remotePlayersGroup);

        // --- Avatar Building Functions ---
        function createFaceTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#F5CD2F'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            const centerX = canvas.width * 0.75; const centerY = canvas.height * 0.5;
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.arc(centerX - 40, centerY - 20, 12, 0, Math.PI * 2); 
            ctx.arc(centerX + 40, centerY - 20, 12, 0, Math.PI * 2); ctx.fill();
            ctx.lineWidth = 8; ctx.strokeStyle = '#111';
            ctx.beginPath(); ctx.arc(centerX, centerY, 50, 0.2 * Math.PI, 0.8 * Math.PI); ctx.stroke();
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function createNameTag(name) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 128; // Larger resolution for sharper text
            
            // Text Shadow/Outline for readability
            ctx.font = 'Bold 60px Arial';
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // Background pill (optional, can make transparent)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            const textWidth = ctx.measureText(name).width;
            const bgWidth = textWidth + 40;
            ctx.roundRect(256 - bgWidth/2, 64 - 40, bgWidth, 80, 20);
            ctx.fill();

            ctx.fillStyle = 'white';
            ctx.fillText(name, 256, 64);
            
            const tex = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: tex, depthTest: false, transparent: true });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(6, 1.5, 1); // Wider scale for longer names
            sprite.position.y = 5.5; // FIXED: Moved up above head (Head top is approx 5.2)
            sprite.name = "nametag"; // Naming it allows us to find and replace it later
            return sprite;
        }

        function createAvatar(isLocal) {
            const group = new THREE.Group();
            const parts = {};
            
            // ... (Geometry definitions remain the same) ...
            const torsoGeo = new THREE.BoxGeometry(2, 2, 1);
            const limbGeo = new THREE.BoxGeometry(1, 2, 1);
            const headGeo = new THREE.CylinderGeometry(0.6, 0.6, 1.2, 32);

            const skinMat = new THREE.MeshStandardMaterial({ color: COLORS.head });
            const faceMat = new THREE.MeshStandardMaterial({ map: createFaceTexture() });
            const torsoMat = new THREE.MeshStandardMaterial({ color: COLORS.torso });
            const armMat = new THREE.MeshStandardMaterial({ color: COLORS.arms });
            const legMat = new THREE.MeshStandardMaterial({ color: COLORS.legs });

            const torso = new THREE.Mesh(torsoGeo, torsoMat);
            torso.position.y = 3; torso.castShadow = true;
            group.add(torso); parts.torso = torso;

            const head = new THREE.Mesh(headGeo, [faceMat, skinMat, skinMat]);
            head.position.y = 1.6; head.rotation.y = -Math.PI / 2;
            torso.add(head); parts.head = head;

            const leftArm = new THREE.Mesh(limbGeo, armMat); 
            const laPivot = new THREE.Group(); laPivot.position.set(-1.5, 0.8, 0); torso.add(laPivot);
            leftArm.position.y = -0.8; leftArm.castShadow = true; laPivot.add(leftArm); parts.leftArm = laPivot;

            const rightArm = new THREE.Mesh(limbGeo, armMat); 
            const raPivot = new THREE.Group(); raPivot.position.set(1.5, 0.8, 0); torso.add(raPivot);
            rightArm.position.y = -0.8; rightArm.castShadow = true; raPivot.add(rightArm); parts.rightArm = raPivot;

            const leftLeg = new THREE.Mesh(limbGeo, legMat); 
            const llPivot = new THREE.Group(); llPivot.position.set(-0.5, -1, 0); torso.add(llPivot);
            leftLeg.position.y = -1; leftLeg.castShadow = true; llPivot.add(leftLeg); parts.leftLeg = llPivot;

            const rightLeg = new THREE.Mesh(limbGeo, legMat); 
            const rlPivot = new THREE.Group(); rlPivot.position.set(0.5, -1, 0); torso.add(rlPivot);
            rightLeg.position.y = -1; rightLeg.castShadow = true; rlPivot.add(rightLeg); parts.rightLeg = rlPivot;

            if(isLocal) group.userData.parts = parts;
            return { group, parts };
        }

        // Init Local Player
        const localAvatar = createAvatar(true);
        playerGroup.add(localAvatar.group);
        const bodyParts = localAvatar.group.userData.parts; 
        
        // --- Firebase Logic ---
        
        document.getElementById('join-btn').addEventListener('click', async () => {
            const nameInput = document.getElementById('username-input').value.trim();
            if (!nameInput) return alert("Please enter a name!");
            localPlayerName = nameInput;
            
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('toggle-editor-btn').style.display = 'block';
            
            if (isOffline) {
                isGameActive = true;
                localPlayerId = 'offline-user';
                log("Playing in Offline Mode");
                return; 
            }

            try {
                log("Attempting to sign in...");
                await signInAnonymously(auth);
            } catch (e) {
                console.error("Auth failed, forcing offline:", e);
                isOffline = true;
                isGameActive = true; 
                document.getElementById('network-status').textContent = "Offline (Auth Failed)";
                log("Auth Failed. Switched to Offline.");
            }
        });

        if (!isOffline) {
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    localPlayerId = user.uid;
                    isGameActive = true;
                    document.getElementById('network-status').textContent = "Online";
                    log("Signed in as: " + user.uid);
                    startPlayerSync();
                    startWorldSync();
                }
            });
        }

        let lastSyncTime = 0;
        function syncLocalPlayer() {
            if (isOffline || !localPlayerId || !isGameActive) return;
            const now = Date.now();
            if (now - lastSyncTime < 100) return; 
            
            lastSyncTime = now;
            // Using Simplified 'players' collection
            const playerRef = doc(db, 'players', localPlayerId); 
            setDoc(playerRef, {
                x: playerGroup.position.x,
                y: playerGroup.position.y,
                z: playerGroup.position.z,
                rot: playerGroup.rotation.y,
                name: localPlayerName,
                lastSeen: serverTimestamp()
            }, { merge: true });
        }

        // --- HANDLE DISCONNECT ---
        window.addEventListener('beforeunload', () => {
            if (localPlayerId && !isOffline) {
                // Attempt to delete player doc on exit (Best effort)
                // Note: This relies on the browser sending the request before closing
                deleteDoc(doc(db, 'players', localPlayerId));
            }
        });

        // --- STALE PLAYER CLEANUP ---
        // If a player crashes, they won't delete their doc. 
        // This loop removes players locally if they haven't moved in 10 seconds.
        setInterval(() => {
            const now = Date.now();
            Object.keys(remotePlayers).forEach(uid => {
                const p = remotePlayers[uid];
                if (now - p.lastUpdate > 10000) { // 10 seconds timeout
                    console.log("Removing stale player:", uid);
                    remotePlayersGroup.remove(p.group);
                    delete remotePlayers[uid];
                }
            });
        }, 2000);

        function startPlayerSync() {
            if (isOffline) return;
            log("Starting Player Sync...");
            const playersRef = collection(db, 'players'); 
            onSnapshot(playersRef, (snapshot) => {
                const currentIds = [];
                snapshot.forEach((doc) => {
                    const data = doc.data();
                    const uid = doc.id;
                    if (uid === localPlayerId) return; 
                    
                    currentIds.push(uid);
                    
                    let p = remotePlayers[uid];
                    
                    // 1. Spawn if not exists
                    if (!p) {
                        log("Found new player: " + (data.name || "Guest"));
                        const remote = createAvatar(false);
                        // Initial tag creation
                        remote.group.add(createNameTag(data.name || "Guest"));
                        
                        remotePlayersGroup.add(remote.group);
                        remotePlayers[uid] = { 
                            group: remote.group, 
                            targetPos: new THREE.Vector3(), 
                            targetRot: 0,
                            parts: remote.parts,
                            lastUpdate: Date.now(),
                            currentName: data.name || "Guest"
                        };
                        p = remotePlayers[uid];
                    }
                    
                    // 2. Update Name Tag if name changed in DB (Fixes "Guest" issue)
                    const newName = data.name || "Guest";
                    if (p.currentName !== newName) {
                        log(`Player ${uid} changed name to ${newName}`);
                        const oldTag = p.group.getObjectByName("nametag");
                        if (oldTag) p.group.remove(oldTag);
                        
                        p.group.add(createNameTag(newName));
                        p.currentName = newName;
                    }
                    
                    // 3. Update Position Targets
                    if (data.x !== undefined) {
                        p.targetPos.set(data.x, data.y, data.z);
                        p.targetRot = data.rot;
                        p.lastUpdate = Date.now(); 
                    }
                });
                
                // Cleanup
                Object.keys(remotePlayers).forEach(uid => {
                    if (!currentIds.includes(uid)) {
                        log("Player left: " + uid);
                        remotePlayersGroup.remove(remotePlayers[uid].group);
                        delete remotePlayers[uid];
                    }
                });
            }, (error) => {
                log("SYNC ERROR: " + error.message);
                console.warn("Sync Error:", error);
            });
        }

        function startWorldSync() {
            if (isOffline) return;
            log("Starting World Sync...");
            const worldRef = collection(db, 'worldObjects');
            onSnapshot(worldRef, (snapshot) => {
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const id = change.doc.id;
                    if (change.type === "added") { spawnRemotePart(id, data); }
                    if (change.type === "modified") updateRemotePart(id, data);
                    if (change.type === "removed") {
                        const mesh = worldObjects[id];
                        if (mesh) {
                            mesh.parent.remove(mesh);
                            delete worldObjects[id];
                        }
                    }
                });
            }, (error) => log("WORLD ERROR: " + error.message));
        }

        function spawnRemotePart(id, data) {
            if (worldObjects[id]) return; 
            
            let geometry;
            if (data.type === 'box') geometry = new THREE.BoxGeometry(1, 1, 1);
            else if (data.type === 'cylinder') geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
            else if (data.type === 'wedge') {
                const shape = new THREE.Shape();
                shape.moveTo(0,0); shape.lineTo(1,0); shape.lineTo(0,1); shape.lineTo(0,0);
                geometry = new THREE.ExtrudeGeometry(shape, { depth: 1, bevelEnabled: false });
                geometry.translate(-0.5, -0.5, -0.5);
            }

            const mat = new THREE.MeshStandardMaterial({ color: data.color });
            const mesh = new THREE.Mesh(geometry, mat);
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.position.set(data.px, data.py, data.pz);
            mesh.rotation.set(data.rx, data.ry, data.rz);
            mesh.scale.set(data.sx, data.sy, data.sz);
            
            mesh.userData = { 
                isCustom: true, isWorld: true, anchored: data.anchored, 
                canCollide: data.canCollide, dbId: id, mode: 'world' 
            };
            
            worldGroup.add(mesh);
            worldObjects[id] = mesh;
        }

        function updateRemotePart(id, data) {
            const mesh = worldObjects[id];
            if (!mesh) return;
            if (selectedObject === mesh && isEditing) return;

            mesh.position.set(data.px, data.py, data.pz);
            mesh.rotation.set(data.rx, data.ry, data.rz);
            mesh.scale.set(data.sx, data.sy, data.sz);
            mesh.material.color.setHex(data.color);
            mesh.userData.anchored = data.anchored;
            mesh.userData.canCollide = data.canCollide;
        }

        // --- Game Logic ---
        const keys = { w: false, a: false, s: false, d: false, " ": false };
        let isShiftLock = false, isRightClickRotating = false, isFirstPerson = false;
        let velocityY = 0, isGrounded = true;
        const playerDirection = new THREE.Vector3();
        const clock = new THREE.Clock();
        
        // Controls & Camera - DEFINE FUNCTION BEFORE USE
        const cameraParams = { distance: 10, targetDistance: 10, theta: 0, phi: Math.PI / 4, minDistance: 2, maxDistance: 80, sensitivity: 0.002, offsetY: 4.5 };
        
        function updateCameraPosition() {
            cameraParams.distance = THREE.MathUtils.lerp(cameraParams.distance, cameraParams.targetDistance, 0.2);
            const r = cameraParams.distance, phi = cameraParams.phi, theta = cameraParams.theta;
            const x = r * Math.sin(phi) * Math.sin(theta);
            const y = r * Math.cos(phi);
            const z = r * Math.sin(phi) * Math.cos(theta);
            
            const targetPos = playerGroup.position.clone();
            targetPos.y += cameraParams.offsetY; 
            camera.position.set(targetPos.x + x, targetPos.y + y, targetPos.z + z);
            camera.lookAt(targetPos);

            if (cameraParams.distance < 2.5 && !isFirstPerson) { isFirstPerson = true; playerGroup.visible = false; } 
            else if (cameraParams.distance >= 2.5 && isFirstPerson) { isFirstPerson = false; playerGroup.visible = true; }
        }

        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.setSpace('local');
        scene.add(transformControl);
        const selectionHelper = new THREE.BoxHelper();
        selectionHelper.material.depthTest = false; selectionHelper.material.transparent = true; selectionHelper.visible = false;
        scene.add(selectionHelper);
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isEditing = false, activeTab = 'avatar', selectedObject = null, isPickingParent = false;
        const actionHistory = []; let tempTransformState = null, clipboard = null;

        // --- EDITOR MODIFICATIONS ---
        window.gameEditor = {
            setTab: function(tab) {
                activeTab = tab;
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('tab-' + tab).classList.add('active');
                document.getElementById('content-avatar').classList.toggle('hidden', tab !== 'avatar');
                document.getElementById('content-world').classList.toggle('hidden', tab !== 'world');
                this.clearSelection();
            },
            toggle: function() {
                isEditing = !isEditing;
                const ui = document.getElementById('editor-ui');
                const btn = document.getElementById('toggle-editor-btn');
                const gameUI = document.getElementById('ui-layer');

                if (isEditing) {
                    ui.style.display = 'block'; gameUI.style.opacity = '0.2'; btn.textContent = 'Exit Tools';
                    document.exitPointerLock(); isShiftLock = false;
                    document.getElementById('shift-status').textContent = "OFF";
                    document.getElementById('crosshair').style.display = "none";
                } else {
                    ui.style.display = 'none'; gameUI.style.opacity = '1'; btn.textContent = 'Open Tools';
                    this.clearSelection(); isPickingParent = false;
                }
            },
            addPart: function(type, overrideData) { if (!isEditing) return; this.createObject(type, 'avatar', overrideData); },
            
            addWorldPart: function(type, overrideData) {
                if (!isEditing) return;
                if (isOffline) return this.createObject(type, 'world', overrideData); // Fallback for local

                const spawnPos = playerGroup.position.clone().add(new THREE.Vector3(0, 2, 5)); 
                addDoc(collection(db, 'worldObjects'), { // Simplified Path
                    type: type,
                    px: spawnPos.x, py: spawnPos.y, pz: spawnPos.z,
                    rx: 0, ry: 0, rz: 0,
                    sx: 1, sy: 1, sz: 1,
                    color: Math.random() * 0xffffff,
                    anchored: true, canCollide: true, owner: localPlayerId
                });
            },
            
            createObject: function(type, mode, data) {
                // In multiplayer mode, world objects are created via Firestore listener. 
                // This function is used for local Avatar parts OR offline world parts.
                if (mode === 'world' && !isOffline && !data) return; 

                let geometry;
                if (type === 'box') geometry = new THREE.BoxGeometry(1, 1, 1);
                else if (type === 'cylinder') geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
                const color = data ? data.color : Math.random() * 0xffffff;
                const mat = new THREE.MeshStandardMaterial({ color: color });
                const mesh = new THREE.Mesh(geometry, mat);
                mesh.castShadow = true;
                
                // Setup metadata
                mesh.userData = { 
                    isCustom: true, 
                    mode: mode, 
                    anchored: (mode === 'world'), 
                    canCollide: true,
                    velocity: new THREE.Vector3() 
                };

                let parent;
                if (mode === 'world') parent = worldGroup;
                else parent = bodyParts[document.getElementById('parent-selector').value];
                
                parent.add(mesh);
                
                if (data) { mesh.position.copy(data.pos); mesh.rotation.copy(data.rot); mesh.scale.copy(data.scl); } 
                else if (mode === 'world') {
                     const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
                     mesh.position.copy(playerGroup.position).add(fwd.multiplyScalar(5)).addScalar(0, 2, 0);
                } else { mesh.position.set(0, 0, 1); }
                
                this.selectObject(mesh);
            },

            selectObject: function(mesh) {
                if(selectedObject === mesh) return;
                selectedObject = mesh;
                transformControl.attach(mesh);
                selectionHelper.setFromObject(mesh);
                selectionHelper.visible = true;
                if (mesh.userData.mode === 'world') transformControl.setSpace('world');
                else transformControl.setSpace('local');
                document.getElementById('color-picker').value = '#' + mesh.material.color.getHexString();
                document.getElementById('check-anchor').checked = mesh.userData.anchored;
                document.getElementById('check-collide').checked = mesh.userData.canCollide;
            },
            clearSelection: function() {
                transformControl.detach(); selectionHelper.visible = false; selectedObject = null;
            },
            captureTransformEnd: function(obj) {
                if (obj.userData.mode === 'world' && obj.userData.dbId && !isOffline) {
                    const ref = doc(db, 'worldObjects', obj.userData.dbId); // Simplified Path
                    updateDoc(ref, {
                        px: obj.position.x, py: obj.position.y, pz: obj.position.z,
                        rx: obj.rotation.x, ry: obj.rotation.y, rz: obj.rotation.z,
                        sx: obj.scale.x, sy: obj.scale.y, sz: obj.scale.z
                    });
                }
            },
            captureTransformStart: function(obj) {},
            setAnchored: function(val) {
                if(selectedObject) {
                    selectedObject.userData.anchored = val;
                    if(selectedObject.userData.dbId && !isOffline) updateDoc(doc(db, 'worldObjects', selectedObject.userData.dbId), { anchored: val }); // Simplified Path
                }
            },
            setCanCollide: function(val) {
                if(selectedObject) {
                    selectedObject.userData.canCollide = val;
                    if(selectedObject.userData.dbId && !isOffline) updateDoc(doc(db, 'worldObjects', selectedObject.userData.dbId), { canCollide: val }); // Simplified Path
                }
            },
            deleteSelected: function() {
                if(selectedObject) {
                    if (selectedObject.userData.dbId && !isOffline) deleteDoc(doc(db, 'worldObjects', selectedObject.userData.dbId)); // Simplified Path
                    else selectedObject.parent.remove(selectedObject);
                    this.clearSelection();
                }
            },
            setMode: function(mode) {
                transformControl.setMode(mode);
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('mode-' + mode).classList.add('active');
            },
            undo: function() { console.log("Undo not fully supported in Multiplayer mode yet"); },
            copy: function() {}, paste: function() {}, startPickParent: function() {}
        };

        transformControl.addEventListener('dragging-changed', (event) => {
            if (!event.value && selectedObject) window.gameEditor.captureTransformEnd(selectedObject);
        });

        document.getElementById('toggle-editor-btn').addEventListener('click', () => window.gameEditor.toggle());
        document.getElementById('baseplate-color-picker').addEventListener('input', (e) => ground.material.color.set(e.target.value));
        
        renderer.domElement.addEventListener('pointerdown', (event) => {
            if (event.button === 2) { isRightClickRotating = true; document.body.requestPointerLock(); return; }
            if (!isEditing) return;
            if (event.button !== 0) return; 
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...worldGroup.children, ...playerGroup.children], true);
            for (let i = 0; i < intersects.length; i++) {
                const obj = intersects[i].object;
                if (obj.userData.isCustom || obj.userData.isWorld) {
                    window.gameEditor.selectObject(obj);
                    return;
                }
            }
        });
        
        document.addEventListener('pointerup', (event) => {
            if (event.button === 2) { isRightClickRotating = false; if (!isShiftLock) document.exitPointerLock(); }
        });

        window.addEventListener('keydown', (event) => {
            const key = event.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = true;
            if (event.key === " ") keys[" "] = true;
            if (event.key === 'Shift') toggleShiftLock();
            
            if (isEditing) {
                const k = event.key.toLowerCase();
                if(k === '1') window.gameEditor.setMode('translate');
                if(k === '2') window.gameEditor.setMode('rotate');
                if(k === '3') window.gameEditor.setMode('scale');
                if(k === 'delete') window.gameEditor.deleteSelected();
                if(k === 'escape') window.gameEditor.toggle();
            }
        });
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) keys[key] = false;
            if (e.key === " ") keys[" "] = false;
        });

        // --- Physics & Movement ---
        const wallRaycaster = new THREE.Raycaster();
        const floorRaycaster = new THREE.Raycaster();

        function checkMove(proposedMoveX, proposedMoveZ) {
            const moveVec = new THREE.Vector3(proposedMoveX, 0, proposedMoveZ);
            const dist = moveVec.length();
            if (dist < 0.001) return { x: 0, z: 0 };
            
            const dir = moveVec.clone().normalize();
            const origin = playerGroup.position.clone().add(new THREE.Vector3(0, 1, 0));
            
            wallRaycaster.set(origin, dir);
            const collidables = worldGroup.children.filter(o => o.userData.canCollide !== false);
            const intersects = wallRaycaster.intersectObjects(collidables, true);
            
            if (intersects.length > 0 && intersects[0].distance < 1.0 + dist) {
                 return { x: 0, z: 0 }; 
            }
            return { x: proposedMoveX, z: proposedMoveZ };
        }

        function updatePhysics(delta) {
            worldGroup.children.forEach(part => {
                if (part.userData.isWorld && !part.userData.anchored) {
                     part.updateMatrixWorld(); 
                     if (!part.userData.velocity) part.userData.velocity = new THREE.Vector3();
                     part.userData.velocity.y += GRAVITY * delta;
                     part.position.addScaledVector(part.userData.velocity, delta);
                     
                     const box = new THREE.Box3().setFromObject(part);
                     if (box.min.y < 0) {
                         const overlap = 0 - box.min.y;
                         part.position.y += overlap;
                         if (part.userData.velocity.y < 0) {
                            part.userData.velocity.y = -part.userData.velocity.y * 0.3;
                            part.userData.velocity.x *= 0.8; part.userData.velocity.z *= 0.8;
                            if (Math.abs(part.userData.velocity.y) < 1) part.userData.velocity.y = 0; 
                         }
                     }
                }
            });

            const origin = playerGroup.position.clone().add(new THREE.Vector3(0, 2, 0));
            floorRaycaster.set(origin, new THREE.Vector3(0, -1, 0));
            const collidables = worldGroup.children.filter(o => o.userData.canCollide !== false);
            let floorHeight = 0;
            const intersects = floorRaycaster.intersectObjects(collidables, true);
            if (intersects.length > 0) {
                const hitY = intersects[0].point.y;
                if (hitY > floorHeight) floorHeight = hitY;
            }
            
            if (keys[" "] && isGrounded) { velocityY = JUMP_FORCE; isGrounded = false; }
            velocityY += GRAVITY * delta;
            playerGroup.position.y += velocityY * delta;

            if (playerGroup.position.y < floorHeight) {
                playerGroup.position.y = floorHeight;
                velocityY = 0;
                isGrounded = true;
            } else {
                isGrounded = (Math.abs(playerGroup.position.y - floorHeight) < 0.1);
            }
        }

        function updatePlayer(delta) {
            if (isEditing && activeTab === 'avatar') {
                updateCameraPosition();
                return; 
            }

            const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
            const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0));
            
            playerDirection.set(0,0,0);
            if(keys.w) playerDirection.add(fwd);
            if(keys.s) playerDirection.sub(fwd);
            if(keys.a) playerDirection.sub(right);
            if(keys.d) playerDirection.add(right);

            const isMoving = playerDirection.lengthSq() > 0;

            if (isMoving) {
                playerDirection.normalize();
                const moveDist = WALK_SPEED * delta;
                const moveX = playerDirection.x * moveDist;
                const moveZ = playerDirection.z * moveDist;

                const resX = checkMove(moveX, 0);
                playerGroup.position.x += resX.x;
                const resZ = checkMove(0, moveZ);
                playerGroup.position.z += resZ.z;
                
                if (isShiftLock) {
                    playerGroup.rotation.y = cameraParams.theta + Math.PI;
                } else {
                    const targetRot = Math.atan2(playerDirection.x, playerDirection.z);
                    let rotDiff = (targetRot + Math.PI) - playerGroup.rotation.y; 
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    playerGroup.rotation.y += rotDiff * ROTATION_SPEED * delta;
                }
            } else if (isShiftLock) {
                playerGroup.rotation.y = cameraParams.theta + Math.PI;
            }
            
            updatePhysics(delta);
            updateAnimation(delta, isMoving);
            updateCameraPosition();
            syncLocalPlayer(); 
            updateRemoteAvatars(delta); 
        }

        function updateAnimation(delta, isMoving) {
             const lerpFactor = 15 * delta;
             const bodyParts = localAvatar.group.userData.parts; 
             if (isMoving && isGrounded) {
                const time = clock.getElapsedTime() * 12;
                bodyParts.leftLeg.rotation.x = Math.sin(time) * 0.8;
                bodyParts.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.8;
                bodyParts.leftArm.rotation.x = Math.sin(time + Math.PI) * 0.8;
                bodyParts.rightArm.rotation.x = Math.sin(time) * 0.8;
            } else {
                bodyParts.leftLeg.rotation.x = THREE.MathUtils.lerp(bodyParts.leftLeg.rotation.x, isGrounded ? 0 : 0.5, lerpFactor);
                bodyParts.rightLeg.rotation.x = THREE.MathUtils.lerp(bodyParts.rightLeg.rotation.x, isGrounded ? 0 : -0.5, lerpFactor);
                bodyParts.leftArm.rotation.x = THREE.MathUtils.lerp(bodyParts.leftArm.rotation.x, isGrounded ? 0 : Math.PI, lerpFactor);
                bodyParts.rightArm.rotation.x = THREE.MathUtils.lerp(bodyParts.rightArm.rotation.x, isGrounded ? 0 : Math.PI, lerpFactor);
            }
        }
        
        function updateRemoteAvatars(delta) {
            const lerpFactor = 5 * delta;
            Object.values(remotePlayers).forEach(p => {
                p.group.position.lerp(p.targetPos, lerpFactor);
                let rotDiff = p.targetRot - p.group.rotation.y;
                while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                p.group.rotation.y += rotDiff * lerpFactor;
                const speed = p.group.position.distanceTo(p.targetPos) / delta;
                const isMoving = speed > 0.1;
                const time = clock.getElapsedTime() * 12;
                if (isMoving) {
                    p.parts.leftLeg.rotation.x = Math.sin(time) * 0.8;
                    p.parts.rightLeg.rotation.x = Math.sin(time + Math.PI) * 0.8;
                    p.parts.leftArm.rotation.x = Math.sin(time + Math.PI) * 0.8;
                    p.parts.rightArm.rotation.x = Math.sin(time) * 0.8;
                } else {
                    p.parts.leftLeg.rotation.x = THREE.MathUtils.lerp(p.parts.leftLeg.rotation.x, 0, lerpFactor);
                    p.parts.rightLeg.rotation.x = THREE.MathUtils.lerp(p.parts.rightLeg.rotation.x, 0, lerpFactor);
                    p.parts.leftArm.rotation.x = THREE.MathUtils.lerp(p.parts.leftArm.rotation.x, 0, lerpFactor);
                    p.parts.rightArm.rotation.x = THREE.MathUtils.lerp(p.parts.rightArm.rotation.x, 0, lerpFactor);
                }
            });
        }

        document.addEventListener('mousemove', (e) => {
            const isLocked = document.pointerLockElement === document.body;
            if (isLocked) {
                cameraParams.theta -= e.movementX * cameraParams.sensitivity;
                cameraParams.phi -= e.movementY * cameraParams.sensitivity;
                cameraParams.phi = Math.max(0.01, Math.min(Math.PI / 2 - 0.1, cameraParams.phi));
            }
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            if (isGameActive) updatePlayer(delta);
            if(selectedObject && selectionHelper.visible) selectionHelper.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
