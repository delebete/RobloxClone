<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blox World: Hybrid Networking</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #232527; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* Debugger */
        #debug-console {
            position: absolute; top: 10px; left: 10px; width: 300px; height: 150px;
            background: rgba(0, 0, 0, 0.7); color: #0f0; font-family: monospace; font-size: 11px;
            padding: 10px; border-radius: 4px; pointer-events: none; overflow-y: auto; z-index: 300;
            white-space: pre-wrap;
        }

        /* Room Code HUD */
        #room-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6); padding: 10px 20px; border-radius: 20px;
            color: white; font-weight: bold; font-size: 16px; pointer-events: none;
            z-index: 100; display: none; border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #room-hud span { color: #00ffaa; font-family: monospace; font-size: 18px; margin-left: 5px; }
        #room-hud .mode-badge { font-size: 10px; background: #444; padding: 2px 6px; border-radius: 4px; margin-left: 10px; vertical-align: middle; text-transform: uppercase; }

        /* Login Modal */
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #232527; z-index: 200; display: flex; justify-content: center; align-items: center; flex-direction: column;
        }
        .login-box {
            background: #393b3d; padding: 30px; border-radius: 10px; text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); width: 340px;
        }
        .login-box h1 { color: white; margin-top: 0; margin-bottom: 5px;}
        .login-box p { color: #aaa; font-size: 12px; margin-bottom: 15px; }
        
        .input-group { margin-bottom: 15px; text-align: left; }
        .input-group label { display: block; color: #ccc; margin-bottom: 5px; font-size: 12px; }
        .login-box input[type="text"] {
            width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #555;
            background: #232527; color: white; font-size: 14px; box-sizing: border-box;
        }
        
        /* Toggle Switch */
        .mode-switch-container {
            background: #2a2c2e; padding: 10px; border-radius: 6px; margin-bottom: 15px;
            display: flex; align-items: center; justify-content: space-between;
            border: 1px solid #444;
        }
        .mode-label { color: white; font-size: 14px; font-weight: bold; }
        .switch { position: relative; display: inline-block; width: 40px; height: 20px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc; transition: .4s; border-radius: 20px;
        }
        .slider:before {
            position: absolute; content: ""; height: 16px; width: 16px; left: 2px; bottom: 2px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #00a2ff; }
        input:checked + .slider:before { transform: translateX(20px); }
        .mode-desc { font-size: 10px; color: #888; margin-top: 5px; text-align: left; }

        #server-url-container { display: none; margin-bottom: 15px; text-align: left; }

        .btn-row { display: flex; gap: 10px; margin-top: 10px; }
        .btn-primary {
            flex: 1; padding: 12px; background: #00a2ff; color: white; border: none;
            border-radius: 5px; font-size: 14px; font-weight: bold; cursor: pointer;
        }
        .btn-primary:hover { background: #008ecc; }
        .btn-secondary {
            flex: 1; padding: 12px; background: #444; color: white; border: 1px solid #555;
            border-radius: 5px; font-size: 14px; font-weight: bold; cursor: pointer;
        }
        .btn-secondary:hover { background: #555; }
        
        #host-id-display-container { display: none; margin-top: 15px; background: #222; padding: 15px; border-radius: 5px; border: 1px solid #444; }
        #host-id-text { color: #00ffaa; font-family: monospace; font-size: 24px; letter-spacing: 2px; font-weight: bold; margin: 5px 0; }
        #copy-btn { margin-top: 5px; background: #333; color: white; border: none; padding: 5px 10px; cursor: pointer; font-size: 10px; border-radius: 3px; }

        #network-status { position: absolute; bottom: 10px; left: 10px; color: #888; font-size: 12px; pointer-events: none; z-index: 201; }

        /* Game UI */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 8px;
            pointer-events: none; user-select: none; max-width: 300px; transition: opacity 0.3s;
        }
        
        /* Tools UI */
        #editor-ui {
            position: absolute; top: 60px; right: 20px; width: 240px;
            background: rgba(35, 37, 39, 0.95); color: white; padding: 15px;
            border-radius: 8px; border: 1px solid #444; display: none;
            max-height: calc(100vh - 140px); overflow-y: auto; z-index: 90;
        }
        
        #toggle-editor-btn {
            position: absolute; bottom: 20px; right: 20px; padding: 10px 20px;
            background: #00a2ff; color: white; border: none; border-radius: 4px;
            font-weight: bold; cursor: pointer; font-size: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); pointer-events: auto; z-index: 100; 
            display: none;
        }
        #toggle-editor-btn:hover { background: #008ecc; }

        /* Editor Styling */
        .editor-section { margin-bottom: 15px; border-bottom: 1px solid #555; padding-bottom: 10px; }
        .editor-section h3 { margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; color: #ccc; }
        .editor-row { display: flex; gap: 5px; margin-bottom: 5px; }
        .tab-row { display: flex; margin-bottom: 15px; border-bottom: 2px solid #444; }
        .tab-btn { flex: 1; background: transparent; border: none; color: #aaa; padding: 8px; cursor: pointer; font-weight: bold; border-bottom: 2px solid transparent; margin-bottom: -2px; }
        .tab-btn.active { color: #00a2ff; border-bottom-color: #00a2ff; }
        button.tool-btn { flex: 1; padding: 5px; background: #444; border: 1px solid #555; color: white; cursor: pointer; border-radius: 3px; }
        button.tool-btn:hover { background: #555; }
        button.tool-btn.active { background: #00a2ff; border-color: #00a2ff; }
        .checkbox-row { display: flex; align-items: center; gap: 10px; margin: 5px 0; background: #333; padding: 5px; border-radius: 4px; }
        input[type="checkbox"] { width: auto; margin: 0; cursor: pointer; }
        select, input[type="color"] { width: 100%; padding: 5px; background: #333; border: 1px solid #555; color: white; border-radius: 3px; margin-bottom: 5px; pointer-events: auto; }
        label { font-size: 12px; color: #aaa; display: block; margin-bottom: 2px; }

        /* Crosshair */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 10; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.8); border-radius: 2px; }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        .key { background: #ddd; color: #333; padding: 2px 6px; border-radius: 4px; font-weight: bold; display: inline-block; min-width: 15px; text-align: center; }
        .status-badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 12px; background: #444; margin-top: 5px; }
        .on { background: #2ecc71; color: white; }
        .off { background: #e74c3c; color: white; }
        .hidden { display: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- Login Screen -->
    <div id="login-screen">
        <div class="login-box">
            <h1>Blox World</h1>
            <p>Multiplayer Demo</p>
            
            <div class="mode-switch-container">
                <div class="mode-label">Connection: <span id="mode-text">P2P</span></div>
                <label class="switch">
                    <input type="checkbox" id="net-mode-toggle">
                    <span class="slider"></span>
                </label>
            </div>
            <div class="mode-desc" id="mode-desc">
                Direct connection. Free, but blocked by school Wi-Fi.
            </div>

            <!-- Server URL Input (Hidden by default) -->
            <div id="server-url-container">
                <label style="color:#ccc; font-size:12px;">Server URL (Glitch/Render)</label>
                <input type="text" id="server-url-input" placeholder="https://your-project.glitch.me">
            </div>
            
            <div class="input-group">
                <label>Username</label>
                <input type="text" id="username-input" placeholder="Your Name" maxlength="12" value="Guest">
            </div>

            <div class="btn-row">
                <button class="btn-secondary" id="host-btn">Host Game</button>
            </div>

            <div style="margin: 15px 0; border-bottom: 1px solid #555; position: relative;">
                <span style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: #393b3d; padding: 0 10px; color: #888; font-size: 12px;">OR JOIN</span>
            </div>

            <div class="input-group">
                <label>Room Code (6 Digits)</label>
                <input type="text" id="host-id-input" placeholder="e.g. 123456" maxlength="6" style="letter-spacing: 2px; font-family: monospace;">
            </div>
            
            <button class="btn-primary" id="join-btn">Join Game</button>
            
            <div id="host-id-display-container">
                <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Share this Code:</div>
                <div id="host-id-text">...</div>
                <button id="copy-btn">Copy to Clipboard</button>
            </div>
            
            <p id="connection-msg" style="color:#ff4444; font-size:12px; margin-top:10px; display:none;"></p>
        </div>
    </div>

    <div id="room-hud">
        CODE: <span id="room-code-display"></span>
        <span id="mode-badge" class="mode-badge">P2P</span>
    </div>
    <div id="network-status">Idle</div>
    <div id="debug-console">System Ready...</div>

    <div id="crosshair"></div>

    <div id="ui-layer">
        <h1>Controls</h1>
        <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> to Walk</p>
        <p><span class="key">Space</span> to Jump</p>
        <p><span class="key">Shift</span> Toggle Shift Lock</p>
        <p><span class="key">Right Click (Hold)</span> Rotate Camera</p>
        <div style="margin-top: 10px; border-top: 1px solid #666; padding-top: 10px;">
            <div>Shift Lock: <span id="shift-status" class="status-badge off">OFF</span></div>
        </div>
    </div>

    <button id="toggle-editor-btn">Open Tools</button>

    <div id="editor-ui">
        <div class="tab-row">
            <button class="tab-btn active" id="tab-avatar" onclick="window.gameEditor.setTab('avatar')">Avatar</button>
            <button class="tab-btn" id="tab-world" onclick="window.gameEditor.setTab('world')">Building</button>
        </div>
        
        <div id="content-avatar">
            <div class="editor-section">
                <h3>Wearables</h3>
                <div class="editor-row">
                    <button class="tool-btn" onclick="window.gameEditor.addPart('box')">Cube</button>
                    <button class="tool-btn" onclick="window.gameEditor.addPart('cylinder')">Cylinder</button>
                </div>
                <label>Attach To:</label>
                <select id="parent-selector">
                    <option value="torso">Torso</option>
                    <option value="head">Head</option>
                    <option value="leftArm">Left Arm</option>
                    <option value="rightArm">Right Arm</option>
                    <option value="leftLeg">Left Leg</option>
                    <option value="rightLeg">Right Leg</option>
                </select>
            </div>
        </div>

        <div id="content-world" class="hidden">
            <div class="editor-section">
                <h3>Create Part</h3>
                <div class="editor-row">
                    <button class="tool-btn" onclick="window.gameEditor.addWorldPart('box')">Part</button>
                    <button class="tool-btn" onclick="window.gameEditor.addWorldPart('cylinder')">Cylinder</button>
                </div>
                <div class="editor-row">
                      <button class="tool-btn" onclick="window.gameEditor.addWorldPart('wedge')">Wedge</button>
                </div>
            </div>
            <div class="editor-section">
                <h3>Baseplate</h3>
                <label>Baseplate Color</label>
                <input type="color" id="baseplate-color-picker" value="#999999">
            </div>
        </div>

        <div class="editor-section">
            <h3>Tools</h3>
            <div class="editor-row">
                <button class="tool-btn active" id="mode-translate" onclick="window.gameEditor.setMode('translate')">Move (1)</button>
                <button class="tool-btn" id="mode-rotate" onclick="window.gameEditor.setMode('rotate')">Rotate (2)</button>
                <button class="tool-btn" id="mode-scale" onclick="window.gameEditor.setMode('scale')">Scale (3)</button>
            </div>
            <label style="margin-top:5px;">Properties</label>
            <div class="checkbox-row">
                <input type="checkbox" id="check-anchor" checked onchange="window.gameEditor.setAnchored(this.checked)">
                <label for="check-anchor" style="color:white; cursor:pointer; margin:0;">Anchored</label>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="check-collide" checked onchange="window.gameEditor.setCanCollide(this.checked)">
                <label for="check-collide" style="color:white; cursor:pointer; margin:0;">Can Collide</label>
            </div>
            <label>Color</label>
            <input type="color" id="color-picker" value="#ff0000">
            <button class="tool-btn" style="background: #e74c3c; margin-top:5px; width:100%;" onclick="window.gameEditor.deleteSelected()">Delete Selected</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        function log(msg) {
            const consoleEl = document.getElementById('debug-console');
            consoleEl.innerText += `\n> ${msg}`;
            consoleEl.scrollTop = consoleEl.scrollHeight;
            console.log(msg);
        }

        // --- NETWORK GLOBAL STATE ---
        const NetState = {
            mode: 'p2p', // 'p2p' or 'server'
            isHost: false,
            // P2P Stuff
            peer: null,
            conn: null,
            connections: [],
            // Server Stuff
            socket: null,
            id: null, // My ID
            code: null
        };

        let localPlayerName = "Guest";
        let isGameActive = false;
        const remotePlayers = {}; 
        const worldObjects = {}; 

        // --- CONFIGS ---
        const P2P_PREFIX = 'blox-p2p-2025-';
        const peerConfig = {
            config: {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    {
                        urls: "turn:openrelay.metered.ca:80",
                        username: "openrelayproject",
                        credential: "openrelayproject"
                    }
                ]
            }
        };

        // --- UI LOGIC: MODE TOGGLE ---
        const toggleEl = document.getElementById('net-mode-toggle');
        const modeTextEl = document.getElementById('mode-text');
        const modeDescEl = document.getElementById('mode-desc');
        const serverUrlContainer = document.getElementById('server-url-container');
        const serverUrlInput = document.getElementById('server-url-input');

        // Load saved URL
        if(localStorage.getItem('blox_server_url')) {
            serverUrlInput.value = localStorage.getItem('blox_server_url');
        }

        toggleEl.addEventListener('change', () => {
            if(toggleEl.checked) {
                NetState.mode = 'server';
                modeTextEl.textContent = "Server";
                modeDescEl.textContent = "Requires Hosting. Bypasses all firewalls. No limits.";
                serverUrlContainer.style.display = 'block';
            } else {
                NetState.mode = 'p2p';
                modeTextEl.textContent = "P2P";
                modeDescEl.textContent = "Direct connection. Free, but blocked by school Wi-Fi.";
                serverUrlContainer.style.display = 'none';
            }
        });

        // --- GENERIC HANDLER ---
        function handleGameData(data) {
            switch(data.type) {
                case 'WELCOME':
                    log(`Joined! ${data.players.length} players.`);
                    data.players.forEach(p => updateRemotePlayer(p.id, p));
                    data.world.forEach(w => spawnRemotePart(w.id, w));
                    break;
                case 'PLAYER_UPDATE':
                    // If host in P2P, relay
                    if (NetState.mode === 'p2p' && NetState.isHost) {
                        NetState.connections.forEach(c => { if (c.peer !== data.senderId) c.send(data); });
                    }
                    updateRemotePlayer(data.id, data);
                    break;
                case 'PLAYER_LEAVE':
                    removeRemotePlayer(data.id);
                    break;
                case 'WORLD_CREATE':
                    spawnRemotePart(data.data.id, data.data);
                    break;
                case 'WORLD_UPDATE':
                    updateRemotePart(data.id, data.data);
                    break;
                case 'WORLD_DELETE':
                    deleteWorldPart(data.id);
                    break;
                // Socket specific reqs are handled by server relay usually
            }
        }

        // --- HOSTING ---
        document.getElementById('host-btn').addEventListener('click', () => {
            localPlayerName = document.getElementById('username-input').value || "Host";
            
            if (NetState.mode === 'p2p') {
                hostP2P();
            } else {
                hostServer();
            }
        });

        // --- JOINING ---
        document.getElementById('join-btn').addEventListener('click', () => {
            const code = document.getElementById('host-id-input').value.trim();
            if(!code || code.length !== 6) return alert("Invalid Code");
            localPlayerName = document.getElementById('username-input').value || "Guest";

            if (NetState.mode === 'p2p') {
                joinP2P(code);
            } else {
                joinServer(code);
            }
        });

        // ==========================================
        //               P2P LOGIC (PeerJS)
        // ==========================================
        function hostP2P() {
            const code = Math.floor(100000 + Math.random() * 900000).toString();
            NetState.isHost = true;
            NetState.code = code;
            
            document.getElementById('network-status').textContent = "Init P2P Host...";
            NetState.peer = new window.Peer(P2P_PREFIX + code, peerConfig);
            
            NetState.peer.on('open', (id) => {
                NetState.id = id;
                setupGameUI(code, 'P2P');
            });
            
            NetState.peer.on('connection', (conn) => {
                NetState.connections.push(conn);
                conn.on('data', (data) => {
                    // Add senderId for relay logic
                    data.senderId = conn.peer; 
                    
                    // Logic for requests
                    if(data.type === 'REQ_WORLD_CREATE') {
                        const id = Math.random().toString(36).substr(2, 9);
                        const finalData = { ...data.data, id: id };
                        spawnRemotePart(id, finalData);
                        broadcastP2P({ type: 'WORLD_CREATE', data: finalData });
                    }
                    else if(data.type === 'REQ_WORLD_UPDATE') {
                        updateRemotePart(data.id, data.data);
                        broadcastP2P({ type: 'WORLD_UPDATE', id: data.id, data: data.data });
                    }
                    else if(data.type === 'REQ_WORLD_DELETE') {
                        deleteWorldPart(data.id);
                        broadcastP2P({ type: 'WORLD_DELETE', id: data.id });
                    }
                    else {
                        handleGameData(data);
                    }
                });
                
                conn.on('open', () => {
                    // Send Welcome
                    const players = Object.values(remotePlayers).map(p => ({
                        id: p.id, x: p.group.position.x, y: p.group.position.y, z: p.group.position.z, 
                        rot: p.group.rotation.y, name: p.currentName
                    }));
                    players.push({
                        id: NetState.id, x: playerGroup.position.x, y: playerGroup.position.y, z: playerGroup.position.z,
                        rot: playerGroup.rotation.y, name: localPlayerName
                    });
                    const world = Object.values(worldObjects).map(obj => serializeObject(obj));
                    conn.send({ type: 'WELCOME', players, world });
                });
                
                conn.on('close', () => {
                    NetState.connections = NetState.connections.filter(c => c !== conn);
                    removeRemotePlayer(conn.peer);
                    broadcastP2P({ type: 'PLAYER_LEAVE', id: conn.peer });
                });
            });
        }

        function joinP2P(code) {
            NetState.isHost = false;
            NetState.code = code;
            document.getElementById('network-status').textContent = "Connecting P2P...";
            
            NetState.peer = new window.Peer(undefined, peerConfig);
            NetState.peer.on('open', (id) => {
                NetState.id = id;
                NetState.conn = NetState.peer.connect(P2P_PREFIX + code);
                NetState.conn.on('open', () => {
                    setupGameUI(code, 'P2P');
                });
                NetState.conn.on('data', (data) => handleGameData(data));
                NetState.conn.on('close', () => { alert("Host left"); location.reload(); });
            });
        }

        function broadcastP2P(data) {
            if(NetState.isHost) NetState.connections.forEach(c => c.send(data));
        }

        // ==========================================
        //           SERVER LOGIC (Socket.io)
        // ==========================================
        function connectSocket() {
            const url = serverUrlInput.value.trim();
            if(!url) { alert("Please enter a Server URL"); return null; }
            localStorage.setItem('blox_server_url', url); // Save for later
            
            document.getElementById('network-status').textContent = "Connecting to Server...";
            const socket = io(url);
            
            socket.on('connect_error', (err) => {
                log("Socket Error: " + err.message);
                document.getElementById('connection-msg').textContent = "Server Error. Is it running?";
                document.getElementById('connection-msg').style.display = 'block';
            });
            
            socket.on('disconnect', () => { log("Disconnected from server"); });
            
            // Game Events
            socket.on('welcome', (data) => handleGameData({ type: 'WELCOME', ...data }));
            socket.on('player_update', (data) => handleGameData({ type: 'PLAYER_UPDATE', ...data }));
            socket.on('player_leave', (id) => handleGameData({ type: 'PLAYER_LEAVE', id }));
            socket.on('world_create', (data) => handleGameData({ type: 'WORLD_CREATE', data }));
            socket.on('world_update', (data) => handleGameData({ type: 'WORLD_UPDATE', id: data.id, data: data.data }));
            socket.on('world_delete', (id) => handleGameData({ type: 'WORLD_DELETE', id }));
            
            return socket;
        }

        function hostServer() {
            NetState.socket = connectSocket();
            if(!NetState.socket) return;
            
            NetState.socket.on('connect', () => {
                NetState.id = NetState.socket.id;
                // Request room creation
                NetState.socket.emit('create_room', { name: localPlayerName }, (response) => {
                     NetState.code = response.code;
                     setupGameUI(response.code, 'SERVER');
                });
            });
        }

        function joinServer(code) {
            NetState.socket = connectSocket();
            if(!NetState.socket) return;

            NetState.socket.on('connect', () => {
                NetState.id = NetState.socket.id;
                NetState.socket.emit('join_room', { code, name: localPlayerName }, (response) => {
                    if(response.success) {
                         setupGameUI(code, 'SERVER');
                    } else {
                        alert("Join failed: " + response.message);
                    }
                });
            });
        }

        // ==========================================
        //              SHARED GAME LOGIC
        // ==========================================
        function setupGameUI(code, mode) {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('toggle-editor-btn').style.display = 'block';
            document.getElementById('room-hud').style.display = 'block';
            document.getElementById('room-code-display').textContent = code;
            document.getElementById('mode-badge').textContent = mode;
            document.getElementById('network-status').textContent = "Connected (" + mode + ")";
            
            // Show host code if we just hosted
            if (NetState.isHost || mode === 'SERVER') { // Server logic often treats room creator as just a client
                document.getElementById('host-id-text').textContent = code;
                // For Server mode, we might want to show the share box initially
            }
            
            isGameActive = true;
        }

        function serializeObject(mesh) {
            return {
                id: mesh.userData.dbId,
                type: mesh.userData.type,
                px: mesh.position.x, py: mesh.position.y, pz: mesh.position.z,
                rx: mesh.rotation.x, ry: mesh.rotation.y, rz: mesh.rotation.z,
                sx: mesh.scale.x, sy: mesh.scale.y, sz: mesh.scale.z,
                color: mesh.material.color.getHex(),
                anchored: mesh.userData.anchored,
                canCollide: mesh.userData.canCollide
            };
        }

        // 3D Scene, Player Logic, Editor Logic...
        // (Keeping this part concise but fully functional as per previous iterations)
        
        const COLORS = { head: 0xF5CD2F, torso: 0x0D69AC, arms: 0xF5CD2F, legs: 0xA4BD47, baseplate: 0x999999 };
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 250);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), new THREE.MeshStandardMaterial({ color: COLORS.baseplate }));
        ground.rotation.x = -Math.PI / 2; ground.receiveShadow = true;
        ground.userData = { isWorld: true, anchored: true, canCollide: true };
        scene.add(ground);

        const worldGroup = new THREE.Group(); scene.add(worldGroup);
        const playerGroup = new THREE.Group(); scene.add(playerGroup);
        const remotePlayersGroup = new THREE.Group(); scene.add(remotePlayersGroup);

        // Avatar Creation
        function createFaceTexture() {
            const c = document.createElement('canvas'); c.width=64; c.height=32;
            const ctx = c.getContext('2d'); ctx.fillStyle='#F5CD2F'; ctx.fillRect(0,0,64,32);
            ctx.fillStyle='#000'; ctx.fillRect(18,10,4,4); ctx.fillRect(42,10,4,4); 
            ctx.beginPath(); ctx.arc(32,20,6,0,Math.PI); ctx.stroke();
            return new THREE.CanvasTexture(c);
        }
        
        function createAvatar(isLocal) {
            const g = new THREE.Group(); const parts = {};
            const mat = { 
                head: new THREE.MeshStandardMaterial({map:createFaceTexture()}), 
                body: new THREE.MeshStandardMaterial({color:COLORS.torso}),
                limb: new THREE.MeshStandardMaterial({color:COLORS.arms}),
                leg: new THREE.MeshStandardMaterial({color:COLORS.legs})
            };
            
            const torso = new THREE.Mesh(new THREE.BoxGeometry(2,2,1), mat.body);
            torso.position.y=3; g.add(torso); parts.torso = torso;
            
            const head = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,1.2,16), mat.head);
            head.position.y=1.6; head.rotation.y=-Math.PI/2; torso.add(head); parts.head = head;
            
            function addLimb(x, y, mat, name) {
                const m = new THREE.Mesh(new THREE.BoxGeometry(1,2,1), mat);
                const piv = new THREE.Group(); piv.position.set(x,y,0); torso.add(piv);
                m.position.y = -1; piv.add(m); parts[name] = piv;
            }
            addLimb(-1.5, 1, mat.limb, 'leftArm'); addLimb(1.5, 1, mat.limb, 'rightArm');
            addLimb(-0.5, -1, mat.leg, 'leftLeg'); addLimb(0.5, -1, mat.leg, 'rightLeg');
            
            // Name Tag
            const cvs = document.createElement('canvas'); cvs.width=256; cvs.height=64;
            const ctx = cvs.getContext('2d'); ctx.font="bold 40px Arial"; ctx.textAlign="center";
            ctx.fillStyle="white"; ctx.fillText("Player", 128, 48); ctx.strokeStyle="black"; ctx.strokeText("Player", 128, 48);
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cvs)}));
            sprite.position.y=5; sprite.scale.set(4,1,1); sprite.name="nametag"; g.add(sprite);
            
            if(isLocal) g.userData.parts = parts;
            return { group: g, parts };
        }

        const localAvatar = createAvatar(true);
        playerGroup.add(localAvatar.group);

        // UPDATE FUNCTIONS
        function sendPlayerUpdate() {
            if(!isGameActive) return;
            const data = {
                id: NetState.id, name: localPlayerName,
                x: playerGroup.position.x, y: playerGroup.position.y, z: playerGroup.position.z,
                rot: playerGroup.rotation.y
            };

            if (NetState.mode === 'p2p') {
                if (NetState.isHost) broadcastP2P({ type: 'PLAYER_UPDATE', ...data });
                else if (NetState.conn) NetState.conn.send({ type: 'PLAYER_UPDATE', ...data });
            } else if (NetState.mode === 'server' && NetState.socket) {
                NetState.socket.emit('player_update', data);
            }
        }

        function updateRemotePlayer(id, data) {
            if(id === NetState.id) return;
            let p = remotePlayers[id];
            if(!p) {
                const av = createAvatar(false);
                // Update nametag
                const sprite = av.group.getObjectByName("nametag");
                const ctx = sprite.material.map.image.getContext('2d');
                ctx.clearRect(0,0,256,64); ctx.fillText(data.name, 128, 48); ctx.strokeText(data.name, 128, 48);
                sprite.material.map.needsUpdate = true;
                
                remotePlayersGroup.add(av.group);
                p = remotePlayers[id] = { group: av.group, parts: av.parts, target: new THREE.Vector3(), rot: 0 };
            }
            p.target.set(data.x, data.y, data.z);
            p.rot = data.rot;
        }

        function removeRemotePlayer(id) {
            if(remotePlayers[id]) {
                remotePlayersGroup.remove(remotePlayers[id].group);
                delete remotePlayers[id];
            }
        }
        
        // EDITOR & WORLD
        function spawnRemotePart(id, data) {
             if(worldObjects[id]) return;
             const geo = data.type==='cylinder' ? new THREE.CylinderGeometry(0.5,0.5,1) : new THREE.BoxGeometry(1,1,1);
             const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:data.color}));
             mesh.position.set(data.px, data.py, data.pz);
             mesh.rotation.set(data.rx, data.ry, data.rz);
             mesh.scale.set(data.sx, data.sy, data.sz);
             mesh.userData = { isCustom:true, isWorld:true, dbId:id, anchored:data.anchored, canCollide:data.canCollide };
             worldGroup.add(mesh);
             worldObjects[id] = mesh;
        }
        
        function updateRemotePart(id, data) {
            const m = worldObjects[id];
            if(!m) return;
            m.position.set(data.px, data.py, data.pz);
            m.rotation.set(data.rx, data.ry, data.rz);
            m.scale.set(data.sx, data.sy, data.sz);
            m.material.color.setHex(data.color);
            m.userData.anchored = data.anchored;
            m.userData.canCollide = data.canCollide;
        }
        
        function deleteWorldPart(id) {
            if(worldObjects[id]) {
                worldObjects[id].parent.remove(worldObjects[id]);
                delete worldObjects[id];
            }
        }

        // EDITOR INTERFACE implementation
        window.gameEditor = {
            setTab: (t) => {
                document.getElementById('content-avatar').style.display = t==='avatar'?'block':'none';
                document.getElementById('content-world').style.display = t==='world'?'block':'none';
            },
            toggle: () => {
                isEditing = !isEditing;
                document.getElementById('editor-ui').style.display = isEditing?'block':'none';
                if(isEditing) { document.exitPointerLock(); document.getElementById('toggle-editor-btn').textContent="Close"; }
                else { document.getElementById('toggle-editor-btn').textContent="Tools"; }
            },
            addPart: (t) => { /* Local Avatar Part logic omitted for brevity, same as before */ },
            addWorldPart: (type) => {
                const pos = playerGroup.position.clone().add(new THREE.Vector3(0,2,5));
                const data = {
                    type, px:pos.x, py:pos.y, pz:pos.z, rx:0, ry:0, rz:0, sx:1, sy:1, sz:1,
                    color: Math.floor(Math.random()*0xffffff), anchored:true, canCollide:true
                };
                
                if(NetState.mode === 'p2p') {
                    if(NetState.isHost) {
                        const id = Math.random().toString(36).substr(2,9);
                        spawnRemotePart(id, {...data, id});
                        broadcastP2P({type:'WORLD_CREATE', data:{...data, id}});
                    } else if(NetState.conn) {
                        NetState.conn.send({type:'REQ_WORLD_CREATE', data});
                    }
                } else if (NetState.mode === 'server') {
                    NetState.socket.emit('world_create', data);
                }
            },
            selectObject: (obj) => {
                selectedObject = obj;
                transControls.attach(obj);
                document.getElementById('check-anchor').checked = obj.userData.anchored;
                document.getElementById('check-collide').checked = obj.userData.canCollide;
            },
            deleteSelected: () => {
                if(!selectedObject || !selectedObject.userData.dbId) return;
                const id = selectedObject.userData.dbId;
                if(NetState.mode === 'p2p') {
                    if(NetState.isHost) { deleteWorldPart(id); broadcastP2P({type:'WORLD_DELETE', id}); }
                    else if(NetState.conn) { NetState.conn.send({type:'REQ_WORLD_DELETE', id}); }
                } else {
                    NetState.socket.emit('world_delete', id);
                }
                transControls.detach(); selectedObject=null;
            },
            captureTransformEnd: (obj) => {
                if(!obj.userData.dbId) return;
                const data = {
                     px:obj.position.x, py:obj.position.y, pz:obj.position.z,
                     rx:obj.rotation.x, ry:obj.rotation.y, rz:obj.rotation.z,
                     sx:obj.scale.x, sy:obj.scale.y, sz:obj.scale.z,
                     color:obj.material.color.getHex(),
                     anchored:obj.userData.anchored, canCollide:obj.userData.canCollide
                };
                if(NetState.mode === 'p2p') {
                    if(NetState.isHost) broadcastP2P({type:'WORLD_UPDATE', id:obj.userData.dbId, data});
                    else if(NetState.conn) NetState.conn.send({type:'REQ_WORLD_UPDATE', id:obj.userData.dbId, data});
                } else {
                    NetState.socket.emit('world_update', {id:obj.userData.dbId, data});
                }
            },
            setAnchored: (v) => { if(selectedObject) { selectedObject.userData.anchored=v; window.gameEditor.captureTransformEnd(selectedObject); } },
            setCanCollide: (v) => { if(selectedObject) { selectedObject.userData.canCollide=v; window.gameEditor.captureTransformEnd(selectedObject); } },
            setMode: (m) => transControls.setMode(m)
        };
        
        // Controls & Loop
        const transControls = new TransformControls(camera, renderer.domElement);
        transControls.addEventListener('dragging-changed', e => { if(!e.value && selectedObject) window.gameEditor.captureTransformEnd(selectedObject); });
        scene.add(transControls);
        
        let isEditing = false, selectedObject = null;
        const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2();
        
        renderer.domElement.addEventListener('mousedown', (e) => {
            if(e.button !== 0 || !isEditing) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(worldGroup.children);
            if(intersects.length > 0) window.gameEditor.selectObject(intersects[0].object);
            else { transControls.detach(); selectedObject = null; }
        });

        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        
        // Basic Physics/Movement Loop
        const clock = new THREE.Clock();
        let velocityY = 0;
        
        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            
            if(isGameActive) {
                // 1. Physics
                worldGroup.children.forEach(obj => {
                    if(!obj.userData.anchored) {
                        obj.position.y += -10 * delta; // Simple Gravity
                        if(obj.position.y < 0.5) obj.position.y = 0.5; // Floor
                    }
                });
                
                // 2. Movement
                if(!isEditing) {
                    const speed = 15;
                    const dir = new THREE.Vector3();
                    const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion); fwd.y=0; fwd.normalize();
                    const right = new THREE.Vector3(1,0,0).applyQuaternion(camera.quaternion); right.y=0; right.normalize();
                    
                    if(keys['w']) dir.add(fwd); if(keys['s']) dir.sub(fwd);
                    if(keys['a']) dir.sub(right); if(keys['d']) dir.add(right);
                    
                    if(dir.lengthSq() > 0) {
                         dir.normalize();
                         playerGroup.position.addScaledVector(dir, speed * delta);
                         playerGroup.rotation.y = Math.atan2(dir.x, dir.z);
                    }
                    
                    if(keys[' '] && playerGroup.position.y <= 0.1) velocityY = 20;
                    velocityY += -50 * delta;
                    playerGroup.position.y += velocityY * delta;
                    if(playerGroup.position.y < 0) { playerGroup.position.y = 0; velocityY = 0; }
                }
                
                // 3. Sync
                sendPlayerUpdate();
                
                // 4. Remote Interpolation
                Object.values(remotePlayers).forEach(p => {
                    p.group.position.lerp(p.target, 10 * delta);
                    p.group.rotation.y += (p.rot - p.group.rotation.y) * 10 * delta;
                });

                // 5. Camera
                const camTarget = playerGroup.position.clone().add(new THREE.Vector3(0, 5, 10));
                camera.position.lerp(camTarget, 5 * delta);
                camera.lookAt(playerGroup.position);
            }

            renderer.render(scene, camera);
        }
        animate();
        
        // Buttons
        document.getElementById('toggle-editor-btn').onclick = window.gameEditor.toggle;
        document.getElementById('copy-btn').onclick = () => { navigator.clipboard.writeText(NetState.code); alert("Copied"); };

    </script>
</body>
</html>
