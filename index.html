<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blox World - Multi Mode</title>
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #232527; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* Debugger */
        #debug-console {
            position: absolute; top: 10px; left: 10px; width: 300px; height: 150px;
            background: rgba(0, 0, 0, 0.7); color: #0f0; font-family: monospace; font-size: 11px;
            padding: 10px; border-radius: 4px; pointer-events: none; overflow-y: auto; z-index: 300;
            white-space: pre-wrap;
        }

        /* Room Code HUD */
        #room-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6); padding: 10px 20px; border-radius: 20px;
            color: white; font-weight: bold; font-size: 16px; pointer-events: none;
            z-index: 100; display: none; border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        #room-hud span { color: #00ffaa; font-family: monospace; font-size: 18px; margin-left: 5px; }

        /* Login Modal */
        #login-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #232527; z-index: 200; display: flex; justify-content: center; align-items: center; flex-direction: column;
        }
        .login-box {
            background: #393b3d; padding: 40px; border-radius: 10px; text-align: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5); width: 340px; position: relative;
        }
        .login-box h1 { color: white; margin-top: 0; margin-bottom: 5px;}
        .login-box p { color: #aaa; font-size: 12px; margin-bottom: 20px; }
        
        /* ESC Menu */
        #esc-menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85); z-index: 500; display: none;
            justify-content: center; align-items: center; flex-direction: column;
            backdrop-filter: blur(5px);
        }
        .menu-container {
            background: #2c2f33; padding: 30px; border-radius: 15px; width: 400px;
            text-align: center; border: 1px solid #444; box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .menu-title { color: white; font-size: 24px; font-weight: bold; margin-bottom: 10px; }
        .menu-username { color: #00a2ff; font-size: 18px; margin-bottom: 20px; font-family: monospace; }
        
        #avatar-preview-container {
            width: 200px; height: 200px; background: #111; margin: 0 auto 20px auto;
            border-radius: 10px; border: 2px solid #444; overflow: hidden; position: relative;
        }
        
        .menu-btn {
            width: 100%; padding: 12px; margin: 5px 0; border-radius: 5px; border: none;
            font-weight: bold; font-size: 14px; cursor: pointer; transition: 0.2s;
            background: #444; color: white;
        }
        .menu-btn:hover { background: #555; transform: translateY(-2px); }
        .btn-leave { background: #e74c3c; }
        .btn-leave:hover { background: #c0392b; }
        .btn-save { background: #2ecc71; }
        .btn-save:hover { background: #27ae60; }
        .btn-resume { background: #00a2ff; margin-top: 15px; }
        
        /* Mode Switcher */
        .mode-switch-container {
            display: flex; justify-content: center; margin-bottom: 20px;
            background: #222; padding: 4px; border-radius: 20px; width: fit-content; margin-left: auto; margin-right: auto;
        }
        .mode-btn {
            background: transparent; border: none; color: #888; padding: 8px 20px;
            border-radius: 16px; cursor: pointer; font-size: 12px; font-weight: bold; transition: 0.3s;
        }
        .mode-btn.active { background: #00a2ff; color: white; }

        .input-group { margin-bottom: 15px; text-align: left; }
        .input-group label { display: block; color: #ccc; margin-bottom: 5px; font-size: 12px; }
        .login-box input {
            width: 100%; padding: 10px; border-radius: 5px; border: 1px solid #555;
            background: #232527; color: white; font-size: 14px; box-sizing: border-box;
        }
        
        .btn-row { display: flex; gap: 10px; margin-top: 10px; }
        .btn-primary {
            width: 100%; padding: 12px; background: #00a2ff; color: white; border: none;
            border-radius: 5px; font-size: 14px; font-weight: bold; cursor: pointer;
        }
        .btn-primary:disabled { background: #555; cursor: not-allowed; color: #aaa; }
        .btn-primary:hover:not(:disabled) { background: #008ecc; }
        .btn-secondary {
            flex: 1; padding: 12px; background: #444; color: white; border: 1px solid #555;
            border-radius: 5px; font-size: 14px; font-weight: bold; cursor: pointer;
        }
        .btn-secondary:hover { background: #555; }
        
        #host-id-display-container { display: none; margin-top: 15px; background: #222; padding: 15px; border-radius: 5px; border: 1px solid #444; }
        #host-id-text { color: #00ffaa; font-family: monospace; font-size: 24px; letter-spacing: 2px; font-weight: bold; margin: 5px 0; }
        #copy-btn { margin-top: 5px; background: #333; color: white; border: none; padding: 5px 10px; cursor: pointer; font-size: 10px; border-radius: 3px; }

        #network-status { position: absolute; bottom: 10px; left: 10px; color: #888; font-size: 12px; pointer-events: none; z-index: 201; }

        /* Game UI */
        #ui-layer {
            position: absolute; top: 20px; left: 20px; color: white;
            background: rgba(0, 0, 0, 0.5); padding: 15px; border-radius: 8px;
            pointer-events: none; user-select: none; max-width: 300px; transition: opacity 0.3s;
        }
        
        /* Tools UI */
        #editor-ui {
            position: absolute; top: 60px; right: 20px; width: 240px; /* Moved down slightly */
            background: rgba(35, 37, 39, 0.95); color: white; padding: 15px;
            border-radius: 8px; border: 1px solid #444; display: none;
            max-height: calc(100vh - 140px); overflow-y: auto; z-index: 90;
        }
        
        #toggle-editor-btn {
            position: absolute; bottom: 20px; right: 20px; padding: 10px 20px;
            background: #00a2ff; color: white; border: none; border-radius: 4px;
            font-weight: bold; cursor: pointer; font-size: 16px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); pointer-events: auto; z-index: 100; 
            display: none;
        }
        #toggle-editor-btn:hover { background: #008ecc; }

        /* Editor Styling */
        .editor-section { margin-bottom: 15px; border-bottom: 1px solid #555; padding-bottom: 10px; }
        .editor-section h3 { margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; color: #ccc; }
        .editor-row { display: flex; gap: 5px; margin-bottom: 5px; }
        .tab-row { display: flex; margin-bottom: 15px; border-bottom: 2px solid #444; }
        .tab-btn { flex: 1; background: transparent; border: none; color: #aaa; padding: 8px; cursor: pointer; font-weight: bold; border-bottom: 2px solid transparent; margin-bottom: -2px; }
        .tab-btn.active { color: #00a2ff; border-bottom-color: #00a2ff; }
        button.tool-btn { flex: 1; padding: 5px; background: #444; border: 1px solid #555; color: white; cursor: pointer; border-radius: 3px; }
        button.tool-btn:hover { background: #555; }
        button.tool-btn.active { background: #00a2ff; border-color: #00a2ff; }
        .checkbox-row { display: flex; align-items: center; gap: 10px; margin: 5px 0; background: #333; padding: 5px; border-radius: 4px; }
        input[type="checkbox"] { width: auto; margin: 0; cursor: pointer; }
        select, input[type="color"] { width: 100%; padding: 5px; background: #333; border: 1px solid #555; color: white; border-radius: 3px; margin-bottom: 5px; pointer-events: auto; }
        label { font-size: 12px; color: #aaa; display: block; margin-bottom: 2px; }

        /* Crosshair */
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 10; }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background: rgba(255, 255, 255, 0.8); border-radius: 2px; }
        #crosshair::before { top: 9px; left: 0; width: 20px; height: 2px; }
        #crosshair::after { top: 0; left: 9px; width: 2px; height: 20px; }
        
        .key { background: #ddd; color: #333; padding: 2px 6px; border-radius: 4px; font-weight: bold; display: inline-block; min-width: 15px; text-align: center; }
        .status-badge { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 12px; background: #444; margin-top: 5px; }
        .on { background: #2ecc71; color: white; }
        .off { background: #e74c3c; color: white; }
        .hidden { display: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- Login Screen -->
    <div id="login-screen">
        <div class="login-box">
            <h1>Blox World</h1>
            <div class="mode-switch-container">
                <button class="mode-btn active" id="mode-btn-p2p" onclick="switchLoginMode('p2p')">P2P Multiplayer</button>
                <button class="mode-btn" id="mode-btn-server" onclick="switchLoginMode('server')">Render Server</button>
            </div>

            <div class="input-group">
                <label>Username</label>
                <input type="text" id="username-input" placeholder="Your Name" maxlength="12" value="Guest">
            </div>

            <!-- P2P Section -->
            <div id="section-p2p">
                <div class="btn-row">
                    <button class="btn-secondary" id="host-btn">Host Game</button>
                </div>

                <div style="margin: 15px 0; border-bottom: 1px solid #555; position: relative;">
                    <span style="position: absolute; top: -10px; left: 50%; transform: translateX(-50%); background: #393b3d; padding: 0 10px; color: #888; font-size: 12px;">OR JOIN</span>
                </div>

                <div class="input-group">
                    <label>Room Code (6 Digits)</label>
                    <input type="text" id="host-id-input" placeholder="e.g. 123456" maxlength="6" style="letter-spacing: 2px; font-family: monospace;">
                </div>
                
                <button class="btn-primary" id="join-btn">Join Game</button>
                
                <div id="host-id-display-container">
                    <div style="font-size: 12px; color: #ccc; margin-bottom: 5px;">Share this Code:</div>
                    <div id="host-id-text">...</div>
                    <button id="copy-btn">Copy to Clipboard</button>
                </div>
            </div>

            <!-- Server Section -->
            <div id="section-server" class="hidden">
                <div class="input-group">
                    <label>Server Link (WebSocket URL)</label>
                    <input type="text" id="server-url-input" placeholder="wss://myserver.com" value="wss://blox-server-v4h9.onrender.com">
                </div>
                <p style="color:#888; font-style:italic;">Connects to a standard WebSocket server. Sends/Receives JSON.</p>
                <button class="btn-primary" id="connect-server-btn">Connect to Server</button>
            </div>
            
            <p id="connection-msg" style="color:#ff4444; font-size:12px; margin-top:10px; display:none;"></p>
        </div>
    </div>

    <div id="room-hud">ROOM CODE: <span id="room-code-display"></span></div>
    <div id="network-status">Idle</div>
    <div id="debug-console">System Ready...</div>

    <div id="crosshair"></div>

    <div id="ui-layer">
        <h1>Blox Demo</h1>
        <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> to Walk</p>
        <p><span class="key">Space</span> to Jump</p>
        <p><span class="key">Shift</span> Toggle Shift Lock</p>
        <p><span class="key">Right Click (Hold)</span> Rotate Camera</p>
        <p><span class="key">Scroll</span> Zoom</p>
        <p><span class="key">ESC</span> Menu</p>
        <div style="margin-top: 10px; border-top: 1px solid #666; padding-top: 10px;">
            <div>Shift Lock: <span id="shift-status" class="status-badge off">OFF</span></div>
        </div>
    </div>

    <!-- ESC Menu -->
    <div id="esc-menu">
        <div class="menu-container">
            <div class="menu-title">PAUSED</div>
            <div class="menu-username" id="menu-username-display">Guest</div>
            
            <div id="avatar-preview-container"></div>
            <p style="font-size:10px; color:#888; margin-top:-15px; margin-bottom:15px;">Avatar Preview</p>

            <button class="menu-btn btn-resume" onclick="window.gameEditor.toggleMenu()">RESUME</button>
            <button class="menu-btn btn-save" onclick="window.gameEditor.saveGame()">SAVE GAME (.json)</button>
            
            <div style="display:flex; gap:5px; width:100%; margin: 5px 0;">
                <button class="menu-btn" style="flex:1;" onclick="document.getElementById('load-file-input').click()">LOAD GAME</button>
                <input type="file" id="load-file-input" accept=".json" style="display:none" onchange="window.gameEditor.loadGame(this)">
            </div>

            <button class="menu-btn btn-leave" onclick="window.gameEditor.leaveGame()">LEAVE GAME</button>
        </div>
    </div>

    <button id="toggle-editor-btn">Open Tools</button>

    <div id="editor-ui">
        <div class="tab-row">
            <button class="tab-btn active" id="tab-avatar" onclick="window.gameEditor.setTab('avatar')">Avatar</button>
            <button class="tab-btn" id="tab-world" onclick="window.gameEditor.setTab('world')">Building</button>
        </div>
        
        <div id="content-avatar">
            <div class="editor-section">
                <h3>Wearables</h3>
                <div class="editor-row">
                    <button class="tool-btn" onclick="window.gameEditor.addPart('box')">Cube</button>
                    <button class="tool-btn" onclick="window.gameEditor.addPart('cylinder')">Cylinder</button>
                </div>
                <label>Attach To:</label>
                <select id="parent-selector">
                    <option value="torso">Torso</option>
                    <option value="head">Head</option>
                    <option value="leftArm">Left Arm</option>
                    <option value="rightArm">Right Arm</option>
                    <option value="leftLeg">Left Leg</option>
                    <option value="rightLeg">Right Leg</option>
                </select>
            </div>
        </div>

        <div id="content-world" class="hidden">
            <div class="editor-section">
                <h3>Create Part</h3>
                <div class="editor-row">
                    <button class="tool-btn" onclick="window.gameEditor.addWorldPart('box')">Part</button>
                    <button class="tool-btn" onclick="window.gameEditor.addWorldPart('cylinder')">Cylinder</button>
                </div>
                <div class="editor-row">
                      <button class="tool-btn" onclick="window.gameEditor.addWorldPart('wedge')">Wedge</button>
                </div>
            </div>
            <div class="editor-section">
                <h3>Baseplate</h3>
                <label>Baseplate Color</label>
                <input type="color" id="baseplate-color-picker" value="#999999">
            </div>
        </div>

        <div class="editor-section">
            <h3>Tools</h3>
            <div class="editor-row">
                <button class="tool-btn active" id="mode-translate" onclick="window.gameEditor.setMode('translate')">Move (1)</button>
                <button class="tool-btn" id="mode-rotate" onclick="window.gameEditor.setMode('rotate')">Rotate (2)</button>
                <button class="tool-btn" id="mode-scale" onclick="window.gameEditor.setMode('scale')">Scale (3)</button>
            </div>
            <label style="margin-top:5px;">Properties</label>
            <div class="checkbox-row">
                <input type="checkbox" id="check-anchor" checked onchange="window.gameEditor.setAnchored(this.checked)">
                <label for="check-anchor" style="color:white; cursor:pointer; margin:0;">Anchored</label>
            </div>
            <div class="checkbox-row">
                <input type="checkbox" id="check-collide" checked onchange="window.gameEditor.setCanCollide(this.checked)">
                <label for="check-collide" style="color:white; cursor:pointer; margin:0;">Can Collide</label>
            </div>
            <label>Color</label>
            <input type="color" id="color-picker" value="#ff0000">
            <button class="tool-btn" style="background: #e74c3c; margin-top:5px; width:100%;" onclick="window.gameEditor.deleteSelected()">Delete Selected</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        function log(msg) {
            const consoleEl = document.getElementById('debug-console');
            consoleEl.innerText += `\n> ${msg}`;
            consoleEl.scrollTop = consoleEl.scrollHeight;
            console.log(msg);
        }

        // --- GLOBAL VARIABLES ---
        window.switchLoginMode = function(mode) {
            const p2pBtn = document.getElementById('mode-btn-p2p');
            const srvBtn = document.getElementById('mode-btn-server');
            const p2pSec = document.getElementById('section-p2p');
            const srvSec = document.getElementById('section-server');
            const msgEl = document.getElementById('connection-msg');
            msgEl.style.display = 'none';

            if(mode === 'p2p') {
                p2pBtn.classList.add('active'); srvBtn.classList.remove('active');
                p2pSec.classList.remove('hidden'); srvSec.classList.add('hidden');
            } else {
                srvBtn.classList.add('active'); p2pBtn.classList.remove('active');
                srvSec.classList.remove('hidden'); p2pSec.classList.add('hidden');
            }
        };

        const APP_PREFIX = 'blox-p2p-2025-'; 
        
        function generateId() {
            return Math.random().toString(36).substr(2, 9);
        }
        
        const localSessionId = 'user-' + generateId();

        const NetState = {
            mode: 'none',
            isHost: false,
            peer: null,
            conn: null, 
            connections: [], 
            code: null,
            serverUrl: null,
            serverSocket: null
        };

        let localPlayerName = "Guest";
        let isGameActive = false;
        const remotePlayers = {}; 
        const worldObjects = {}; 

        const hostBtn = document.getElementById('host-btn');
        const joinBtn = document.getElementById('join-btn');
        const connectServerBtn = document.getElementById('connect-server-btn');
        const statusEl = document.getElementById('network-status');
        const msgEl = document.getElementById('connection-msg');
        const hudEl = document.getElementById('room-hud');
        const codeEl = document.getElementById('room-code-display');

        function initGame(displayText) {
            document.getElementById('login-screen').style.display = 'none';
            document.getElementById('toggle-editor-btn').style.display = 'block';
            hudEl.style.display = 'block';
            codeEl.innerHTML = displayText;
            isGameActive = true;
            document.getElementById('menu-username-display').textContent = localPlayerName;
        }

        // --- UNIVERSAL PROTOCOL HANDLER ---
        function handleNetworkMessage(msg) {
            // Handle Initial State Sync
            if (msg.type === 'INIT') {
                log(`Server Init: ${Object.keys(msg.state).length} entities loaded.`);
                // Process initial state
                Object.values(msg.state).forEach(item => {
                    processEntityUpdate(item.id, item);
                });
                return;
            }

            // Handle P2P / Server Updates
            // Format: { type: 'SET' | 'DELETE', id: '...', data: { ... } }
            
            if (msg.type === 'SET') {
                processEntityUpdate(msg.id, msg.data);
            } else if (msg.type === 'DELETE') {
                processEntityDelete(msg.id);
            }
        }

        function processEntityUpdate(id, data) {
            if (id === localSessionId && NetState.mode === 'server') return; // Ignore echo if server mode
            if (NetState.mode !== 'server' && id === NetState.peer?.id) return; // Ignore echo if P2P

            if (data.kind === 'player') {
                updateRemotePlayer(id, data);
            } else if (data.kind === 'world') {
                spawnRemotePart(id, data);
            } else if (data.kind === 'avatar-part') {
                attachToRemoteAvatar(data.playerId, data);
            }
        }

        function processEntityDelete(id) {
            if (remotePlayers[id]) {
                removeRemotePlayer(id);
            } else if (worldObjects[id]) {
                deleteWorldPart(id);
            } else {
                // Might be an avatar part attached to someone
                // Inefficient lookup but robust for now
                Object.values(remotePlayers).forEach(p => {
                    if (p.attachments && p.attachments[id]) {
                        deleteRemoteAvatarPart(p.id, id);
                    }
                });
            }
        }

        // Helper to send standard updates
        function sendNetworkUpdate(action, id, data) {
            const msg = { type: action, id: id, data: data };
            
            if (NetState.mode === 'server') {
                if (NetState.serverSocket?.readyState === WebSocket.OPEN) {
                    NetState.serverSocket.send(JSON.stringify(msg));
                }
            } 
            else if (NetState.mode === 'p2p-host') {
                broadcast(msg);
            } 
            else if (NetState.mode === 'p2p-client' && NetState.conn) {
                NetState.conn.send(msg);
            }
        }

        function broadcast(data) {
            if (!NetState.isHost) return;
            NetState.connections.forEach(c => c.send(data));
        }

        // --- SERVER CONNECT LOGIC ---
        connectServerBtn.addEventListener('click', () => {
            let url = document.getElementById('server-url-input').value.trim();
            if(!url) return;
            
            if (url.startsWith('https://')) url = url.replace('https://', 'wss://');
            else if (url.startsWith('http://')) url = url.replace('http://', 'ws://');
            else if (!url.startsWith('ws://') && !url.startsWith('wss://')) url = 'wss://' + url;

            localPlayerName = document.getElementById('username-input').value || "User";
            NetState.mode = 'server';
            NetState.serverUrl = url;
            
            connectServerBtn.disabled = true;
            connectServerBtn.textContent = "Connecting...";
            msgEl.style.display = 'none';
            
            try {
                NetState.serverSocket = new WebSocket(url);

                NetState.serverSocket.onopen = () => {
                    statusEl.textContent = "Connected to Server";
                    initGame("SERVER LINK: <span style='font-size:14px'>" + url + "</span>");
                    connectServerBtn.disabled = false;
                    connectServerBtn.textContent = "Connect to Server";
                };

                NetState.serverSocket.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleNetworkMessage(data);
                    } catch (e) { console.error(e); }
                };

                NetState.serverSocket.onerror = (error) => {
                    msgEl.innerHTML = "Connection Failed. Server might be waking up.";
                    msgEl.style.display = 'block';
                    connectServerBtn.disabled = false;
                    connectServerBtn.textContent = "Connect to Server";
                };

                NetState.serverSocket.onclose = () => {
                    statusEl.textContent = "Disconnected";
                    if(isGameActive) { alert("Disconnected"); location.reload(); }
                };

            } catch(e) {
                console.error(e);
                connectServerBtn.disabled = false;
            }
        });

        // --- P2P HOSTING & JOINING (Adapted to new Protocol) ---
        // To keep P2P working with the new "SET/DELETE" standard, we adapt the host logic.
        
        function createHost() {
             const code = Math.floor(100000 + Math.random() * 900000).toString();
             NetState.code = code;
             NetState.mode = 'p2p-host';
             
             NetState.peer = new window.Peer(APP_PREFIX + code);
             NetState.peer.on('open', (id) => {
                initGame(code);
                hostBtn.disabled = true;
            });

            NetState.peer.on('connection', (conn) => {
                NetState.connections.push(conn);
                conn.on('data', (data) => handleNetworkMessage(data)); // Handle generic data
                
                conn.on('open', () => {
                    // Send Initial State P2P Style
                    // Gather all entities into a mock 'state' object
                    const state = {};
                    // 1. Remote Players
                    Object.values(remotePlayers).forEach(p => {
                        state[p.id] = { 
                            kind: 'player', id: p.id, x: p.group.position.x, y: p.group.position.y, z: p.group.position.z, 
                            rot: p.group.rotation.y, name: p.currentName 
                        };
                        // Attachments
                        Object.values(p.attachments).forEach(att => { state[att.userData.id] = att.userData; });
                    });
                    // 2. Host Player
                    state[NetState.peer.id] = {
                        kind: 'player', id: NetState.peer.id, x: playerGroup.position.x, y: playerGroup.position.y, z: playerGroup.position.z,
                        rot: playerGroup.rotation.y, name: localPlayerName
                    };
                    // 3. World
                    Object.values(worldObjects).forEach(obj => { state[obj.userData.dbId] = obj.userData; });

                    conn.send({ type: 'INIT', state: state });
                });
                
                conn.on('close', () => {
                    NetState.connections = NetState.connections.filter(c => c !== conn);
                    // In P2P, we rely on explicit leave messages or timeouts, simpler to leave basic cleanup for now
                });
            });
        }

        hostBtn.addEventListener('click', () => {
            localPlayerName = document.getElementById('username-input').value || "Host";
            NetState.isHost = true;
            createHost();
        });

        joinBtn.addEventListener('click', () => {
            const codeInput = document.getElementById('host-id-input').value.trim();
            if (!codeInput) return;
            localPlayerName = document.getElementById('username-input').value || "Guest";
            NetState.isHost = false;
            NetState.mode = 'p2p-client';
            
            NetState.peer = new window.Peer();
            NetState.peer.on('open', (id) => {
                NetState.conn = NetState.peer.connect(APP_PREFIX + codeInput);
                NetState.conn.on('open', () => initGame(codeInput));
                NetState.conn.on('data', (data) => handleNetworkMessage(data));
            });
        });

        // --- 3D SETUP & GAME LOGIC (Unchanged visuals, Updated logic) ---
        const COLORS = { head: 0xF5CD2F, torso: 0x0D69AC, arms: 0xF5CD2F, legs: 0xA4BD47, baseplate: 0x999999 };
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 20, 250);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.001; 
        scene.add(dirLight);
        
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), new THREE.MeshStandardMaterial({ color: COLORS.baseplate, roughness: 0.8 }));
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground); 
        
        const worldGroup = new THREE.Group();
        scene.add(worldGroup);
        const playerGroup = new THREE.Group();
        scene.add(playerGroup); 
        const remotePlayersGroup = new THREE.Group();
        scene.add(remotePlayersGroup);

        const cameraParams = { distance: 10, targetDistance: 10, theta: 0, phi: Math.PI / 4, offsetY: 4.5 };

        // Preview Scene
        const previewScene = new THREE.Scene();
        previewScene.background = new THREE.Color(0x111111);
        const previewCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
        previewCamera.position.set(0, 3, 6);
        previewCamera.lookAt(0, 3, 0);
        const previewRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        previewRenderer.setSize(200, 200);
        document.getElementById('avatar-preview-container').appendChild(previewRenderer.domElement);
        const previewLight = new THREE.DirectionalLight(0xffffff, 1.2);
        previewLight.position.set(2, 5, 5);
        previewScene.add(previewLight);
        previewScene.add(new THREE.AmbientLight(0xffffff, 0.5));
        let previewAvatar = null;

        function createAvatar(isLocal) {
            const group = new THREE.Group();
            const parts = {};
            const torso = new THREE.Mesh(new THREE.BoxGeometry(2, 2, 1), new THREE.MeshStandardMaterial({ color: COLORS.torso }));
            torso.position.y = 3; torso.castShadow = true; group.add(torso); parts.torso = torso;
            const head = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 1.2, 32), new THREE.MeshStandardMaterial({ color: COLORS.head }));
            head.position.y = 1.6; head.rotation.y = -Math.PI/2; torso.add(head); parts.head = head;
            // Limbs
            const limbGeo = new THREE.BoxGeometry(1, 2, 1);
            const armMat = new THREE.MeshStandardMaterial({ color: COLORS.arms });
            const legMat = new THREE.MeshStandardMaterial({ color: COLORS.legs });
            const makeLimb = (x, y, mat, parent) => {
                const mesh = new THREE.Mesh(limbGeo, mat);
                const pivot = new THREE.Group(); pivot.position.set(x, y, 0); parent.add(pivot);
                mesh.position.y = (y < 0) ? -1 : -0.8; mesh.castShadow = true; pivot.add(mesh);
                return pivot;
            };
            parts.leftArm = makeLimb(-1.5, 0.8, armMat, torso);
            parts.rightArm = makeLimb(1.5, 0.8, armMat, torso);
            parts.leftLeg = makeLimb(-0.5, -1, legMat, torso);
            parts.rightLeg = makeLimb(0.5, -1, legMat, torso);
            if(isLocal) group.userData.parts = parts;
            return { group, parts };
        }

        const localAvatar = createAvatar(true);
        playerGroup.add(localAvatar.group);
        const bodyParts = localAvatar.group.userData.parts;

        // --- CORE NETWORKING ---
        let lastUpdate = 0;
        const UPDATE_RATE = 1000 / 15; 

        function sendPlayerUpdate() {
            const now = Date.now();
            if (now - lastUpdate < UPDATE_RATE) return; 
            lastUpdate = now;

            const myId = (NetState.mode === 'server') ? localSessionId : (NetState.peer?.id);
            if (!myId) return;

            const data = {
                kind: 'player',
                id: myId,
                x: playerGroup.position.x,
                y: playerGroup.position.y,
                z: playerGroup.position.z,
                rot: playerGroup.rotation.y,
                name: localPlayerName
            };
            sendNetworkUpdate('SET', myId, data);
        }

        function updateRemotePlayer(id, data) {
            let p = remotePlayers[id];
            if (!p) {
                const remote = createAvatar(false);
                // Basic Name Tag
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width=256; canvas.height=64;
                ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(0,0,256,64);
                ctx.font='Bold 40px Arial'; ctx.fillStyle='white'; ctx.textAlign="center"; ctx.fillText(data.name, 128, 48);
                const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
                sprite.scale.set(4,1,1); sprite.position.y=5.5; remote.group.add(sprite);

                remotePlayersGroup.add(remote.group);
                p = remotePlayers[id] = {
                    id: id, group: remote.group, targetPos: new THREE.Vector3(data.x, data.y, data.z),
                    targetRot: data.rot, parts: remote.parts, currentName: data.name, attachments: {}
                };
            }
            p.targetPos.set(data.x, data.y, data.z);
            p.targetRot = data.rot;
        }

        function removeRemotePlayer(id) {
            if (remotePlayers[id]) {
                remotePlayersGroup.remove(remotePlayers[id].group);
                delete remotePlayers[id];
            }
        }

        function attachToRemoteAvatar(playerId, data) {
            if (!remotePlayers[playerId]) return;
            const p = remotePlayers[playerId];
            if (p.attachments[data.id]) return;

            let geometry = (data.type === 'box') ? new THREE.BoxGeometry(1,1,1) : new THREE.CylinderGeometry(0.5,0.5,1,16);
            const mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: data.color }));
            mesh.castShadow = true;
            mesh.userData = { ...data, id: data.id }; // Ensure local ID match
            
            mesh.position.set(data.px, data.py, data.pz);
            mesh.rotation.set(data.rx, data.ry, data.rz);
            mesh.scale.set(data.sx, data.sy, data.sz);

            if (p.parts[data.parent]) {
                p.parts[data.parent].add(mesh);
                p.attachments[data.id] = mesh;
            }
        }

        function spawnRemotePart(id, data) {
            if (worldObjects[id]) return;
            let geometry;
            if (data.type === 'box') geometry = new THREE.BoxGeometry(1,1,1);
            else if (data.type === 'cylinder') geometry = new THREE.CylinderGeometry(0.5,0.5,1,16);
            else { // wedge
                const shape = new THREE.Shape(); shape.moveTo(0,0); shape.lineTo(1,0); shape.lineTo(0,1); shape.lineTo(0,0);
                geometry = new THREE.ExtrudeGeometry(shape, { depth: 1, bevelEnabled: false });
                geometry.translate(-0.5,-0.5,-0.5);
            }
            const mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: data.color }));
            mesh.castShadow = true; mesh.receiveShadow = true;
            mesh.position.set(data.px, data.py, data.pz);
            mesh.rotation.set(data.rx, data.ry, data.rz);
            mesh.scale.set(data.sx, data.sy, data.sz);
            mesh.userData = { ...data, dbId: id, isWorld: true, anchored: data.anchored, canCollide: data.canCollide };
            
            worldGroup.add(mesh);
            worldObjects[id] = mesh;
        }

        function deleteWorldPart(id) {
            if (worldObjects[id]) {
                worldObjects[id].parent.remove(worldObjects[id]);
                delete worldObjects[id];
            }
        }
        
        function deleteRemoteAvatarPart(playerId, attId) {
            if(remotePlayers[playerId] && remotePlayers[playerId].attachments[attId]) {
                remotePlayers[playerId].attachments[attId].parent.remove(remotePlayers[playerId].attachments[attId]);
                delete remotePlayers[playerId].attachments[attId];
            }
        }

        // --- INTERACTION & TOOLS ---
        const transformControl = new TransformControls(camera, renderer.domElement);
        transformControl.setSpace('local'); scene.add(transformControl);
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isEditing = false, isMenuOpen = false, selectedObject = null;

        window.gameEditor = {
            setTab: (tab) => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.getElementById('tab-'+tab).classList.add('active');
                document.getElementById('content-avatar').classList.toggle('hidden', tab!=='avatar');
                document.getElementById('content-world').classList.toggle('hidden', tab!=='world');
                window.gameEditor.clearSelection();
            },
            toggle: () => {
                isEditing = !isEditing;
                document.getElementById('editor-ui').style.display = isEditing ? 'block' : 'none';
                document.getElementById('toggle-editor-btn').textContent = isEditing ? 'Exit Tools' : 'Open Tools';
                if(isEditing) { document.exitPointerLock(); } else { window.gameEditor.clearSelection(); }
            },
            toggleMenu: () => {
                isMenuOpen = !isMenuOpen;
                const menu = document.getElementById('esc-menu');
                if(isMenuOpen) {
                    menu.style.display = 'flex'; document.exitPointerLock();
                    if(previewAvatar) previewScene.remove(previewAvatar);
                    previewAvatar = localAvatar.group.clone();
                    previewAvatar.position.set(0,0,0); previewAvatar.rotation.set(0,0,0);
                    previewScene.add(previewAvatar);
                } else { menu.style.display = 'none'; }
            },
            leaveGame: () => {
                if (NetState.serverSocket) NetState.serverSocket.close();
                if (NetState.peer) NetState.peer.destroy();
                location.reload();
            },
            addWorldPart: (type, overrideData) => {
                const id = generateId();
                let data = overrideData;
                if(!data) {
                    const pos = playerGroup.position.clone().add(new THREE.Vector3(0, 2, 5));
                    data = { 
                        kind: 'world', type: type, 
                        px: pos.x, py: pos.y, pz: pos.z, rx:0, ry:0, rz:0, sx:1, sy:1, sz:1,
                        color: Math.floor(Math.random()*0xffffff), anchored: true, canCollide: true 
                    };
                } else {
                    data.kind = 'world'; // Ensure kind is set
                }
                // Local Create
                spawnRemotePart(id, data);
                // Network Create
                sendNetworkUpdate('SET', id, data);
            },
            addPart: (type) => {
                if(!isEditing) return;
                const id = generateId();
                const parentName = document.getElementById('parent-selector').value;
                const color = Math.random() * 0xffffff;
                
                // Create Visuals Locally
                let geometry = (type==='box') ? new THREE.BoxGeometry(1,1,1) : new THREE.CylinderGeometry(0.5,0.5,1,16);
                const mesh = new THREE.Mesh(geometry, new THREE.MeshStandardMaterial({ color: color }));
                mesh.castShadow = true; 
                mesh.userData = { isCustom: true, mode: 'avatar', dbId: id, anchored: false, canCollide: true };
                bodyParts[parentName].add(mesh);
                mesh.position.set(0,0,1);
                window.gameEditor.selectObject(mesh);

                // Network Data
                const attData = {
                    kind: 'avatar-part',
                    playerId: (NetState.mode === 'server') ? localSessionId : NetState.peer.id,
                    id: id,
                    type: type, parent: parentName, color: color,
                    px: 0, py: 0, pz: 1, rx: 0, ry: 0, rz: 0, sx: 1, sy: 1, sz: 1
                };
                sendNetworkUpdate('SET', id, attData);
            },
            deleteSelected: () => {
                if(selectedObject) {
                    if(selectedObject.userData.dbId) {
                        sendNetworkUpdate('DELETE', selectedObject.userData.dbId, {});
                    }
                    selectedObject.parent.remove(selectedObject);
                    window.gameEditor.clearSelection();
                }
            },
            selectObject: (mesh) => {
                if(selectedObject === mesh) return;
                selectedObject = mesh;
                transformControl.attach(mesh);
                if (mesh.userData.mode === 'world') transformControl.setSpace('world');
                else transformControl.setSpace('local');
            },
            clearSelection: () => { transformControl.detach(); selectedObject = null; },
            saveGame: () => {
                const saveObj = Object.values(worldObjects).map(obj => {
                    const d = obj.userData;
                    return { 
                        type: d.type, px: obj.position.x, py: obj.position.y, pz: obj.position.z,
                        rx: obj.rotation.x, ry: obj.rotation.y, rz: obj.rotation.z,
                        sx: obj.scale.x, sy: obj.scale.y, sz: obj.scale.z,
                        color: obj.material.color.getHex(), anchored: d.anchored, canCollide: d.canCollide
                    };
                });
                const blob = new Blob([JSON.stringify(saveObj)], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = "blox_save.json"; a.click();
            },
            loadGame: (input) => {
                const file = input.files[0]; if(!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const parts = JSON.parse(e.target.result);
                        parts.forEach((p, i) => setTimeout(() => window.gameEditor.addWorldPart(p.type, p), i*50));
                        window.gameEditor.toggleMenu();
                    } catch(err){ alert("Error loading file"); }
                };
                reader.readAsText(file);
            },
            setMode: (mode) => transformControl.setMode(mode),
            setAnchored: (val) => { if(selectedObject) { selectedObject.userData.anchored = val; updateSelectedNetwork(); } },
            setCanCollide: (val) => { if(selectedObject) { selectedObject.userData.canCollide = val; updateSelectedNetwork(); } }
        };

        function updateSelectedNetwork() {
            if(!selectedObject || !selectedObject.userData.dbId) return;
            const o = selectedObject;
            const d = o.userData;
            
            const updateData = {
                px: o.position.x, py: o.position.y, pz: o.position.z,
                rx: o.rotation.x, ry: o.rotation.y, rz: o.rotation.z,
                sx: o.scale.x, sy: o.scale.y, sz: o.scale.z,
                color: o.material.color.getHex(),
                anchored: d.anchored, canCollide: d.canCollide
            };

            // Re-attach required identifiers for the generic 'SET' command
            if (d.mode === 'avatar') {
                updateData.kind = 'avatar-part';
                updateData.playerId = (NetState.mode === 'server') ? localSessionId : NetState.peer.id;
                updateData.parent = o.parent === bodyParts.torso ? 'torso' : 'head'; // Simplification, ideally store parent name
                // Note: Parent tracking in edit mode needs robust mapping, sticking to basics for now
                updateData.type = d.type;
                updateData.id = d.dbId;
            } else {
                updateData.kind = 'world';
                updateData.type = d.type;
            }

            sendNetworkUpdate('SET', d.dbId, updateData);
        }

        transformControl.addEventListener('dragging-changed', (e) => { if(!e.value) updateSelectedNetwork(); });

        // Input Handling
        document.addEventListener('pointerdown', (e) => {
            if(e.button===2) { document.body.requestPointerLock(); return; }
            if(!isEditing || e.button!==0) return;
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((e.clientX-rect.left)/rect.width)*2-1; mouse.y = -((e.clientY-rect.top)/rect.height)*2+1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([...worldGroup.children, ...playerGroup.children], true);
            const hit = intersects.find(i => i.object.userData.isCustom || i.object.userData.isWorld);
            if(hit) window.gameEditor.selectObject(hit.object);
        });
        
        window.addEventListener('keydown', (e) => {
            const k = e.key.toLowerCase();
            if(k==='w') keys.w=true; if(k==='a') keys.a=true; if(k==='s') keys.s=true; if(k==='d') keys.d=true; if(k===' ') keys[' ']=true;
            if(e.key==='Shift') {
                if(!isMenuOpen && !isEditing) {
                    const isLocked = document.pointerLockElement===document.body;
                    if(!isLocked) document.body.requestPointerLock();
                    else document.exitPointerLock();
                }
            }
            if(k==='escape') {
                if(isEditing) window.gameEditor.toggle(); else window.gameEditor.toggleMenu();
            }
            if(isEditing) {
                if(k==='1') window.gameEditor.setMode('translate');
                if(k==='2') window.gameEditor.setMode('rotate');
                if(k==='3') window.gameEditor.setMode('scale');
                if(k==='delete') window.gameEditor.deleteSelected();
            }
        });
        window.addEventListener('keyup', (e) => {
            const k = e.key.toLowerCase();
            if(k==='w') keys.w=false; if(k==='a') keys.a=false; if(k==='s') keys.s=false; if(k==='d') keys.d=false; if(k===' ') keys[' ']=false;
        });
        document.addEventListener('mousemove', (e) => {
            if(document.pointerLockElement === document.body) {
                cameraParams.theta -= e.movementX * 0.002;
                cameraParams.phi -= e.movementY * 0.002;
                cameraParams.phi = Math.max(0.01, Math.min(Math.PI/2, cameraParams.phi));
            }
        });

        // Main Loop
        const clock = new THREE.Clock();
        function updatePlayer(delta) {
            const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y=0; fwd.normalize();
            const right = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0));
            const move = new THREE.Vector3();
            if(keys.w) move.add(fwd); if(keys.s) move.sub(fwd); if(keys.a) move.sub(right); if(keys.d) move.add(right);
            
            if(move.lengthSq()>0) {
                move.normalize().multiplyScalar(16*delta);
                playerGroup.position.add(move); // Simple movement
                const targetRot = Math.atan2(move.x, move.z);
                let rotDiff = (targetRot + Math.PI) - playerGroup.rotation.y;
                while(rotDiff > Math.PI) rotDiff -= Math.PI*2; while(rotDiff < -Math.PI) rotDiff += Math.PI*2;
                playerGroup.rotation.y += rotDiff * 10 * delta;
                sendPlayerUpdate();
            } else if (document.pointerLockElement === document.body) {
                playerGroup.rotation.y = cameraParams.theta;
                sendPlayerUpdate();
            }
            
            // Simple Camera Follow
            cameraParams.distance = THREE.MathUtils.lerp(cameraParams.distance, 10, 0.1);
            const x = cameraParams.distance * Math.sin(cameraParams.phi) * Math.sin(cameraParams.theta);
            const z = cameraParams.distance * Math.sin(cameraParams.phi) * Math.cos(cameraParams.theta);
            const y = cameraParams.distance * Math.cos(cameraParams.phi);
            camera.position.set(playerGroup.position.x + x, playerGroup.position.y + y + 4.5, playerGroup.position.z + z);
            camera.lookAt(playerGroup.position.x, playerGroup.position.y + 4.5, playerGroup.position.z);

            // Interpolate Remotes
            Object.values(remotePlayers).forEach(p => {
                p.group.position.lerp(p.targetPos, 5*delta);
                let r = p.targetRot - p.group.rotation.y;
                while(r>Math.PI)r-=Math.PI*2; while(r<-Math.PI)r+=Math.PI*2;
                p.group.rotation.y += r*5*delta;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(clock.getDelta(), 0.1);
            if(isGameActive && !isMenuOpen) updatePlayer(delta);
            renderer.render(scene, camera);
            if(isMenuOpen && previewAvatar) {
                previewAvatar.rotation.y += delta;
                previewRenderer.render(previewScene, previewCamera);
            }
        }
        animate();
    </script>
</body>
</html>
